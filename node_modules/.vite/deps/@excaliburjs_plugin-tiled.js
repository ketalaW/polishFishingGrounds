import {
  __commonJS,
  __toESM,
  __webpack_exports__Actor,
  __webpack_exports__AffineMatrix,
  __webpack_exports__Animation,
  __webpack_exports__AnimationStrategy,
  __webpack_exports__BaseAlign,
  __webpack_exports__BodyComponent,
  __webpack_exports__BoundingBox,
  __webpack_exports__CollisionType,
  __webpack_exports__Color,
  __webpack_exports__Component,
  __webpack_exports__Font,
  __webpack_exports__FontUnit,
  __webpack_exports__GraphicsComponent,
  __webpack_exports__ImageSource,
  __webpack_exports__IsometricEntityComponent,
  __webpack_exports__IsometricMap,
  __webpack_exports__Logger,
  __webpack_exports__ParallaxComponent,
  __webpack_exports__Shape,
  __webpack_exports__SpriteSheet,
  __webpack_exports__Text,
  __webpack_exports__TextAlign,
  __webpack_exports__TileMap,
  __webpack_exports__TransformComponent,
  __webpack_exports__Vector,
  __webpack_exports__toRadians,
  __webpack_exports__vec
} from "./chunk-WKQ53UUM.js";

// browser-external:jsdom
var require_jsdom = __commonJS({
  "browser-external:jsdom"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "jsdom" has been externalized for browser compatibility. Cannot access "jsdom.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@excaliburjs/plugin-tiled/build/esm/excalibur-tiled.min.js
var e = __toESM(require_jsdom());
var A = { 668: (e2, t, A2) => {
  var i2 = {};
  (0, A2(805).assign)(i2, A2(303), A2(83), A2(681)), e2.exports = i2;
}, 303: (e2, t, A2) => {
  var i2 = A2(792), a2 = A2(805), s2 = A2(996), r2 = A2(674), n2 = A2(442), o2 = Object.prototype.toString, l2 = 0, g2 = -1, d2 = 0, h2 = 8;
  function c2(e3) {
    if (!(this instanceof c2)) return new c2(e3);
    this.options = a2.assign({ level: g2, method: h2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d2, to: "" }, e3 || {});
    var t2 = this.options;
    t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n2(), this.strm.avail_out = 0;
    var A3 = i2.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
    if (A3 !== l2) throw new Error(r2[A3]);
    if (t2.header && i2.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
      var I3;
      if (I3 = "string" == typeof t2.dictionary ? s2.string2buf(t2.dictionary) : "[object ArrayBuffer]" === o2.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (A3 = i2.deflateSetDictionary(this.strm, I3)) !== l2) throw new Error(r2[A3]);
      this._dict_set = true;
    }
  }
  function I2(e3, t2) {
    var A3 = new c2(t2);
    if (A3.push(e3, true), A3.err) throw A3.msg || r2[A3.err];
    return A3.result;
  }
  c2.prototype.push = function(e3, t2) {
    var A3, r3, n3 = this.strm, g3 = this.options.chunkSize;
    if (this.ended) return false;
    r3 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e3 ? n3.input = s2.string2buf(e3) : "[object ArrayBuffer]" === o2.call(e3) ? n3.input = new Uint8Array(e3) : n3.input = e3, n3.next_in = 0, n3.avail_in = n3.input.length;
    do {
      if (0 === n3.avail_out && (n3.output = new a2.Buf8(g3), n3.next_out = 0, n3.avail_out = g3), 1 !== (A3 = i2.deflate(n3, r3)) && A3 !== l2) return this.onEnd(A3), this.ended = true, false;
      0 !== n3.avail_out && (0 !== n3.avail_in || 4 !== r3 && 2 !== r3) || ("string" === this.options.to ? this.onData(s2.buf2binstring(a2.shrinkBuf(n3.output, n3.next_out))) : this.onData(a2.shrinkBuf(n3.output, n3.next_out)));
    } while ((n3.avail_in > 0 || 0 === n3.avail_out) && 1 !== A3);
    return 4 === r3 ? (A3 = i2.deflateEnd(this.strm), this.onEnd(A3), this.ended = true, A3 === l2) : 2 !== r3 || (this.onEnd(l2), n3.avail_out = 0, true);
  }, c2.prototype.onData = function(e3) {
    this.chunks.push(e3);
  }, c2.prototype.onEnd = function(e3) {
    e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = a2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
  }, t.Deflate = c2, t.deflate = I2, t.deflateRaw = function(e3, t2) {
    return (t2 = t2 || {}).raw = true, I2(e3, t2);
  }, t.gzip = function(e3, t2) {
    return (t2 = t2 || {}).gzip = true, I2(e3, t2);
  };
}, 83: (e2, t, A2) => {
  var i2 = A2(447), a2 = A2(805), s2 = A2(996), r2 = A2(681), n2 = A2(674), o2 = A2(442), l2 = A2(414), g2 = Object.prototype.toString;
  function d2(e3) {
    if (!(this instanceof d2)) return new d2(e3);
    this.options = a2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
    var t2 = this.options;
    t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e3 && e3.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new o2(), this.strm.avail_out = 0;
    var A3 = i2.inflateInit2(this.strm, t2.windowBits);
    if (A3 !== r2.Z_OK) throw new Error(n2[A3]);
    if (this.header = new l2(), i2.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = s2.string2buf(t2.dictionary) : "[object ArrayBuffer]" === g2.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (A3 = i2.inflateSetDictionary(this.strm, t2.dictionary)) !== r2.Z_OK)) throw new Error(n2[A3]);
  }
  function h2(e3, t2) {
    var A3 = new d2(t2);
    if (A3.push(e3, true), A3.err) throw A3.msg || n2[A3.err];
    return A3.result;
  }
  d2.prototype.push = function(e3, t2) {
    var A3, n3, o3, l3, d3, h3 = this.strm, c2 = this.options.chunkSize, I2 = this.options.dictionary, u2 = false;
    if (this.ended) return false;
    n3 = t2 === ~~t2 ? t2 : true === t2 ? r2.Z_FINISH : r2.Z_NO_FLUSH, "string" == typeof e3 ? h3.input = s2.binstring2buf(e3) : "[object ArrayBuffer]" === g2.call(e3) ? h3.input = new Uint8Array(e3) : h3.input = e3, h3.next_in = 0, h3.avail_in = h3.input.length;
    do {
      if (0 === h3.avail_out && (h3.output = new a2.Buf8(c2), h3.next_out = 0, h3.avail_out = c2), (A3 = i2.inflate(h3, r2.Z_NO_FLUSH)) === r2.Z_NEED_DICT && I2 && (A3 = i2.inflateSetDictionary(this.strm, I2)), A3 === r2.Z_BUF_ERROR && true === u2 && (A3 = r2.Z_OK, u2 = false), A3 !== r2.Z_STREAM_END && A3 !== r2.Z_OK) return this.onEnd(A3), this.ended = true, false;
      h3.next_out && (0 !== h3.avail_out && A3 !== r2.Z_STREAM_END && (0 !== h3.avail_in || n3 !== r2.Z_FINISH && n3 !== r2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (o3 = s2.utf8border(h3.output, h3.next_out), l3 = h3.next_out - o3, d3 = s2.buf2string(h3.output, o3), h3.next_out = l3, h3.avail_out = c2 - l3, l3 && a2.arraySet(h3.output, h3.output, o3, l3, 0), this.onData(d3)) : this.onData(a2.shrinkBuf(h3.output, h3.next_out)))), 0 === h3.avail_in && 0 === h3.avail_out && (u2 = true);
    } while ((h3.avail_in > 0 || 0 === h3.avail_out) && A3 !== r2.Z_STREAM_END);
    return A3 === r2.Z_STREAM_END && (n3 = r2.Z_FINISH), n3 === r2.Z_FINISH ? (A3 = i2.inflateEnd(this.strm), this.onEnd(A3), this.ended = true, A3 === r2.Z_OK) : n3 !== r2.Z_SYNC_FLUSH || (this.onEnd(r2.Z_OK), h3.avail_out = 0, true);
  }, d2.prototype.onData = function(e3) {
    this.chunks.push(e3);
  }, d2.prototype.onEnd = function(e3) {
    e3 === r2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = a2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
  }, t.Inflate = d2, t.inflate = h2, t.inflateRaw = function(e3, t2) {
    return (t2 = t2 || {}).raw = true, h2(e3, t2);
  }, t.ungzip = h2;
}, 805: (e2, t) => {
  var A2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
  function i2(e3, t2) {
    return Object.prototype.hasOwnProperty.call(e3, t2);
  }
  t.assign = function(e3) {
    for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
      var A3 = t2.shift();
      if (A3) {
        if ("object" != typeof A3) throw new TypeError(A3 + "must be non-object");
        for (var a3 in A3) i2(A3, a3) && (e3[a3] = A3[a3]);
      }
    }
    return e3;
  }, t.shrinkBuf = function(e3, t2) {
    return e3.length === t2 ? e3 : e3.subarray ? e3.subarray(0, t2) : (e3.length = t2, e3);
  };
  var a2 = { arraySet: function(e3, t2, A3, i3, a3) {
    if (t2.subarray && e3.subarray) e3.set(t2.subarray(A3, A3 + i3), a3);
    else for (var s3 = 0; s3 < i3; s3++) e3[a3 + s3] = t2[A3 + s3];
  }, flattenChunks: function(e3) {
    var t2, A3, i3, a3, s3, r2;
    for (i3 = 0, t2 = 0, A3 = e3.length; t2 < A3; t2++) i3 += e3[t2].length;
    for (r2 = new Uint8Array(i3), a3 = 0, t2 = 0, A3 = e3.length; t2 < A3; t2++) s3 = e3[t2], r2.set(s3, a3), a3 += s3.length;
    return r2;
  } }, s2 = { arraySet: function(e3, t2, A3, i3, a3) {
    for (var s3 = 0; s3 < i3; s3++) e3[a3 + s3] = t2[A3 + s3];
  }, flattenChunks: function(e3) {
    return [].concat.apply([], e3);
  } };
  t.setTyped = function(e3) {
    e3 ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, a2)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, s2));
  }, t.setTyped(A2);
}, 996: (e2, t, A2) => {
  var i2 = A2(805), a2 = true, s2 = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (e3) {
    a2 = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (e3) {
    s2 = false;
  }
  for (var r2 = new i2.Buf8(256), n2 = 0; n2 < 256; n2++) r2[n2] = n2 >= 252 ? 6 : n2 >= 248 ? 5 : n2 >= 240 ? 4 : n2 >= 224 ? 3 : n2 >= 192 ? 2 : 1;
  function o2(e3, t2) {
    if (t2 < 65534 && (e3.subarray && s2 || !e3.subarray && a2)) return String.fromCharCode.apply(null, i2.shrinkBuf(e3, t2));
    for (var A3 = "", r3 = 0; r3 < t2; r3++) A3 += String.fromCharCode(e3[r3]);
    return A3;
  }
  r2[254] = r2[254] = 1, t.string2buf = function(e3) {
    var t2, A3, a3, s3, r3, n3 = e3.length, o3 = 0;
    for (s3 = 0; s3 < n3; s3++) 55296 == (64512 & (A3 = e3.charCodeAt(s3))) && s3 + 1 < n3 && 56320 == (64512 & (a3 = e3.charCodeAt(s3 + 1))) && (A3 = 65536 + (A3 - 55296 << 10) + (a3 - 56320), s3++), o3 += A3 < 128 ? 1 : A3 < 2048 ? 2 : A3 < 65536 ? 3 : 4;
    for (t2 = new i2.Buf8(o3), r3 = 0, s3 = 0; r3 < o3; s3++) 55296 == (64512 & (A3 = e3.charCodeAt(s3))) && s3 + 1 < n3 && 56320 == (64512 & (a3 = e3.charCodeAt(s3 + 1))) && (A3 = 65536 + (A3 - 55296 << 10) + (a3 - 56320), s3++), A3 < 128 ? t2[r3++] = A3 : A3 < 2048 ? (t2[r3++] = 192 | A3 >>> 6, t2[r3++] = 128 | 63 & A3) : A3 < 65536 ? (t2[r3++] = 224 | A3 >>> 12, t2[r3++] = 128 | A3 >>> 6 & 63, t2[r3++] = 128 | 63 & A3) : (t2[r3++] = 240 | A3 >>> 18, t2[r3++] = 128 | A3 >>> 12 & 63, t2[r3++] = 128 | A3 >>> 6 & 63, t2[r3++] = 128 | 63 & A3);
    return t2;
  }, t.buf2binstring = function(e3) {
    return o2(e3, e3.length);
  }, t.binstring2buf = function(e3) {
    for (var t2 = new i2.Buf8(e3.length), A3 = 0, a3 = t2.length; A3 < a3; A3++) t2[A3] = e3.charCodeAt(A3);
    return t2;
  }, t.buf2string = function(e3, t2) {
    var A3, i3, a3, s3, n3 = t2 || e3.length, l2 = new Array(2 * n3);
    for (i3 = 0, A3 = 0; A3 < n3; ) if ((a3 = e3[A3++]) < 128) l2[i3++] = a3;
    else if ((s3 = r2[a3]) > 4) l2[i3++] = 65533, A3 += s3 - 1;
    else {
      for (a3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; s3 > 1 && A3 < n3; ) a3 = a3 << 6 | 63 & e3[A3++], s3--;
      s3 > 1 ? l2[i3++] = 65533 : a3 < 65536 ? l2[i3++] = a3 : (a3 -= 65536, l2[i3++] = 55296 | a3 >> 10 & 1023, l2[i3++] = 56320 | 1023 & a3);
    }
    return o2(l2, i3);
  }, t.utf8border = function(e3, t2) {
    var A3;
    for ((t2 = t2 || e3.length) > e3.length && (t2 = e3.length), A3 = t2 - 1; A3 >= 0 && 128 == (192 & e3[A3]); ) A3--;
    return A3 < 0 || 0 === A3 ? t2 : A3 + r2[e3[A3]] > t2 ? A3 : t2;
  };
}, 269: (e2) => {
  e2.exports = function(e3, t, A2, i2) {
    for (var a2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, r2 = 0; 0 !== A2; ) {
      A2 -= r2 = A2 > 2e3 ? 2e3 : A2;
      do {
        s2 = s2 + (a2 = a2 + t[i2++] | 0) | 0;
      } while (--r2);
      a2 %= 65521, s2 %= 65521;
    }
    return a2 | s2 << 16 | 0;
  };
}, 681: (e2) => {
  e2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
}, 823: (e2) => {
  var t = function() {
    for (var e3, t2 = [], A2 = 0; A2 < 256; A2++) {
      e3 = A2;
      for (var i2 = 0; i2 < 8; i2++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
      t2[A2] = e3;
    }
    return t2;
  }();
  e2.exports = function(e3, A2, i2, a2) {
    var s2 = t, r2 = a2 + i2;
    e3 ^= -1;
    for (var n2 = a2; n2 < r2; n2++) e3 = e3 >>> 8 ^ s2[255 & (e3 ^ A2[n2])];
    return -1 ^ e3;
  };
}, 792: (e2, t, A2) => {
  var i2, a2 = A2(805), s2 = A2(665), r2 = A2(269), n2 = A2(823), o2 = A2(674), l2 = 0, g2 = 4, d2 = 0, h2 = -2, c2 = -1, I2 = 4, u2 = 2, B2 = 8, C2 = 9, p2 = 286, f2 = 30, Q2 = 19, E2 = 2 * p2 + 1, m2 = 15, y2 = 3, w2 = 258, _2 = w2 + y2 + 1, v2 = 42, b2 = 103, k2 = 113, D2 = 666, x2 = 1, L2 = 2, S2 = 3, F2 = 4;
  function G2(e3, t2) {
    return e3.msg = o2[t2], t2;
  }
  function T2(e3) {
    return (e3 << 1) - (e3 > 4 ? 9 : 0);
  }
  function N2(e3) {
    for (var t2 = e3.length; --t2 >= 0; ) e3[t2] = 0;
  }
  function R2(e3) {
    var t2 = e3.state, A3 = t2.pending;
    A3 > e3.avail_out && (A3 = e3.avail_out), 0 !== A3 && (a2.arraySet(e3.output, t2.pending_buf, t2.pending_out, A3, e3.next_out), e3.next_out += A3, t2.pending_out += A3, e3.total_out += A3, e3.avail_out -= A3, t2.pending -= A3, 0 === t2.pending && (t2.pending_out = 0));
  }
  function M2(e3, t2) {
    s2._tr_flush_block(e3, e3.block_start >= 0 ? e3.block_start : -1, e3.strstart - e3.block_start, t2), e3.block_start = e3.strstart, R2(e3.strm);
  }
  function U2(e3, t2) {
    e3.pending_buf[e3.pending++] = t2;
  }
  function O2(e3, t2) {
    e3.pending_buf[e3.pending++] = t2 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t2;
  }
  function q2(e3, t2) {
    var A3, i3, a3 = e3.max_chain_length, s3 = e3.strstart, r3 = e3.prev_length, n3 = e3.nice_match, o3 = e3.strstart > e3.w_size - _2 ? e3.strstart - (e3.w_size - _2) : 0, l3 = e3.window, g3 = e3.w_mask, d3 = e3.prev, h3 = e3.strstart + w2, c3 = l3[s3 + r3 - 1], I3 = l3[s3 + r3];
    e3.prev_length >= e3.good_match && (a3 >>= 2), n3 > e3.lookahead && (n3 = e3.lookahead);
    do {
      if (l3[(A3 = t2) + r3] === I3 && l3[A3 + r3 - 1] === c3 && l3[A3] === l3[s3] && l3[++A3] === l3[s3 + 1]) {
        s3 += 2, A3++;
        do {
        } while (l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && l3[++s3] === l3[++A3] && s3 < h3);
        if (i3 = w2 - (h3 - s3), s3 = h3 - w2, i3 > r3) {
          if (e3.match_start = t2, r3 = i3, i3 >= n3) break;
          c3 = l3[s3 + r3 - 1], I3 = l3[s3 + r3];
        }
      }
    } while ((t2 = d3[t2 & g3]) > o3 && 0 != --a3);
    return r3 <= e3.lookahead ? r3 : e3.lookahead;
  }
  function j2(e3) {
    var t2, A3, i3, s3, o3, l3, g3, d3, h3, c3, I3 = e3.w_size;
    do {
      if (s3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= I3 + (I3 - _2)) {
        a2.arraySet(e3.window, e3.window, I3, I3, 0), e3.match_start -= I3, e3.strstart -= I3, e3.block_start -= I3, t2 = A3 = e3.hash_size;
        do {
          i3 = e3.head[--t2], e3.head[t2] = i3 >= I3 ? i3 - I3 : 0;
        } while (--A3);
        t2 = A3 = I3;
        do {
          i3 = e3.prev[--t2], e3.prev[t2] = i3 >= I3 ? i3 - I3 : 0;
        } while (--A3);
        s3 += I3;
      }
      if (0 === e3.strm.avail_in) break;
      if (l3 = e3.strm, g3 = e3.window, d3 = e3.strstart + e3.lookahead, h3 = s3, c3 = void 0, (c3 = l3.avail_in) > h3 && (c3 = h3), A3 = 0 === c3 ? 0 : (l3.avail_in -= c3, a2.arraySet(g3, l3.input, l3.next_in, c3, d3), 1 === l3.state.wrap ? l3.adler = r2(l3.adler, g3, c3, d3) : 2 === l3.state.wrap && (l3.adler = n2(l3.adler, g3, c3, d3)), l3.next_in += c3, l3.total_in += c3, c3), e3.lookahead += A3, e3.lookahead + e3.insert >= y2) for (o3 = e3.strstart - e3.insert, e3.ins_h = e3.window[o3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[o3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[o3 + y2 - 1]) & e3.hash_mask, e3.prev[o3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = o3, o3++, e3.insert--, !(e3.lookahead + e3.insert < y2)); ) ;
    } while (e3.lookahead < _2 && 0 !== e3.strm.avail_in);
  }
  function J2(e3, t2) {
    for (var A3, i3; ; ) {
      if (e3.lookahead < _2) {
        if (j2(e3), e3.lookahead < _2 && t2 === l2) return x2;
        if (0 === e3.lookahead) break;
      }
      if (A3 = 0, e3.lookahead >= y2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + y2 - 1]) & e3.hash_mask, A3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== A3 && e3.strstart - A3 <= e3.w_size - _2 && (e3.match_length = q2(e3, A3)), e3.match_length >= y2) if (i3 = s2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - y2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= y2) {
        e3.match_length--;
        do {
          e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + y2 - 1]) & e3.hash_mask, A3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart;
        } while (0 != --e3.match_length);
        e3.strstart++;
      } else e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
      else i3 = s2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
      if (i3 && (M2(e3, false), 0 === e3.strm.avail_out)) return x2;
    }
    return e3.insert = e3.strstart < y2 - 1 ? e3.strstart : y2 - 1, t2 === g2 ? (M2(e3, true), 0 === e3.strm.avail_out ? S2 : F2) : e3.last_lit && (M2(e3, false), 0 === e3.strm.avail_out) ? x2 : L2;
  }
  function Z2(e3, t2) {
    for (var A3, i3, a3; ; ) {
      if (e3.lookahead < _2) {
        if (j2(e3), e3.lookahead < _2 && t2 === l2) return x2;
        if (0 === e3.lookahead) break;
      }
      if (A3 = 0, e3.lookahead >= y2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + y2 - 1]) & e3.hash_mask, A3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = y2 - 1, 0 !== A3 && e3.prev_length < e3.max_lazy_match && e3.strstart - A3 <= e3.w_size - _2 && (e3.match_length = q2(e3, A3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === y2 && e3.strstart - e3.match_start > 4096) && (e3.match_length = y2 - 1)), e3.prev_length >= y2 && e3.match_length <= e3.prev_length) {
        a3 = e3.strstart + e3.lookahead - y2, i3 = s2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - y2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2;
        do {
          ++e3.strstart <= a3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + y2 - 1]) & e3.hash_mask, A3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart);
        } while (0 != --e3.prev_length);
        if (e3.match_available = 0, e3.match_length = y2 - 1, e3.strstart++, i3 && (M2(e3, false), 0 === e3.strm.avail_out)) return x2;
      } else if (e3.match_available) {
        if ((i3 = s2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && M2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out) return x2;
      } else e3.match_available = 1, e3.strstart++, e3.lookahead--;
    }
    return e3.match_available && (i3 = s2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < y2 - 1 ? e3.strstart : y2 - 1, t2 === g2 ? (M2(e3, true), 0 === e3.strm.avail_out ? S2 : F2) : e3.last_lit && (M2(e3, false), 0 === e3.strm.avail_out) ? x2 : L2;
  }
  function Y2(e3, t2, A3, i3, a3) {
    this.good_length = e3, this.max_lazy = t2, this.nice_length = A3, this.max_chain = i3, this.func = a3;
  }
  function H2() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = B2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a2.Buf16(2 * E2), this.dyn_dtree = new a2.Buf16(2 * (2 * f2 + 1)), this.bl_tree = new a2.Buf16(2 * (2 * Q2 + 1)), N2(this.dyn_ltree), N2(this.dyn_dtree), N2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a2.Buf16(m2 + 1), this.heap = new a2.Buf16(2 * p2 + 1), N2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a2.Buf16(2 * p2 + 1), N2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function K2(e3) {
    var t2;
    return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = u2, (t2 = e3.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? v2 : k2, e3.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l2, s2._tr_init(t2), d2) : G2(e3, h2);
  }
  function P2(e3) {
    var t2, A3 = K2(e3);
    return A3 === d2 && ((t2 = e3.state).window_size = 2 * t2.w_size, N2(t2.head), t2.max_lazy_match = i2[t2.level].max_lazy, t2.good_match = i2[t2.level].good_length, t2.nice_match = i2[t2.level].nice_length, t2.max_chain_length = i2[t2.level].max_chain, t2.strstart = 0, t2.block_start = 0, t2.lookahead = 0, t2.insert = 0, t2.match_length = t2.prev_length = y2 - 1, t2.match_available = 0, t2.ins_h = 0), A3;
  }
  function z2(e3, t2, A3, i3, s3, r3) {
    if (!e3) return h2;
    var n3 = 1;
    if (t2 === c2 && (t2 = 6), i3 < 0 ? (n3 = 0, i3 = -i3) : i3 > 15 && (n3 = 2, i3 -= 16), s3 < 1 || s3 > C2 || A3 !== B2 || i3 < 8 || i3 > 15 || t2 < 0 || t2 > 9 || r3 < 0 || r3 > I2) return G2(e3, h2);
    8 === i3 && (i3 = 9);
    var o3 = new H2();
    return e3.state = o3, o3.strm = e3, o3.wrap = n3, o3.gzhead = null, o3.w_bits = i3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = s3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + y2 - 1) / y2), o3.window = new a2.Buf8(2 * o3.w_size), o3.head = new a2.Buf16(o3.hash_size), o3.prev = new a2.Buf16(o3.w_size), o3.lit_bufsize = 1 << s3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new a2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t2, o3.strategy = r3, o3.method = A3, P2(e3);
  }
  i2 = [new Y2(0, 0, 0, 0, function(e3, t2) {
    var A3 = 65535;
    for (A3 > e3.pending_buf_size - 5 && (A3 = e3.pending_buf_size - 5); ; ) {
      if (e3.lookahead <= 1) {
        if (j2(e3), 0 === e3.lookahead && t2 === l2) return x2;
        if (0 === e3.lookahead) break;
      }
      e3.strstart += e3.lookahead, e3.lookahead = 0;
      var i3 = e3.block_start + A3;
      if ((0 === e3.strstart || e3.strstart >= i3) && (e3.lookahead = e3.strstart - i3, e3.strstart = i3, M2(e3, false), 0 === e3.strm.avail_out)) return x2;
      if (e3.strstart - e3.block_start >= e3.w_size - _2 && (M2(e3, false), 0 === e3.strm.avail_out)) return x2;
    }
    return e3.insert = 0, t2 === g2 ? (M2(e3, true), 0 === e3.strm.avail_out ? S2 : F2) : (e3.strstart > e3.block_start && (M2(e3, false), e3.strm.avail_out), x2);
  }), new Y2(4, 4, 8, 4, J2), new Y2(4, 5, 16, 8, J2), new Y2(4, 6, 32, 32, J2), new Y2(4, 4, 16, 16, Z2), new Y2(8, 16, 32, 32, Z2), new Y2(8, 16, 128, 128, Z2), new Y2(8, 32, 128, 256, Z2), new Y2(32, 128, 258, 1024, Z2), new Y2(32, 258, 258, 4096, Z2)], t.deflateInit = function(e3, t2) {
    return z2(e3, t2, B2, 15, 8, 0);
  }, t.deflateInit2 = z2, t.deflateReset = P2, t.deflateResetKeep = K2, t.deflateSetHeader = function(e3, t2) {
    return e3 && e3.state ? 2 !== e3.state.wrap ? h2 : (e3.state.gzhead = t2, d2) : h2;
  }, t.deflate = function(e3, t2) {
    var A3, a3, r3, o3;
    if (!e3 || !e3.state || t2 > 5 || t2 < 0) return e3 ? G2(e3, h2) : h2;
    if (a3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || a3.status === D2 && t2 !== g2) return G2(e3, 0 === e3.avail_out ? -5 : h2);
    if (a3.strm = e3, A3 = a3.last_flush, a3.last_flush = t2, a3.status === v2) if (2 === a3.wrap) e3.adler = 0, U2(a3, 31), U2(a3, 139), U2(a3, 8), a3.gzhead ? (U2(a3, (a3.gzhead.text ? 1 : 0) + (a3.gzhead.hcrc ? 2 : 0) + (a3.gzhead.extra ? 4 : 0) + (a3.gzhead.name ? 8 : 0) + (a3.gzhead.comment ? 16 : 0)), U2(a3, 255 & a3.gzhead.time), U2(a3, a3.gzhead.time >> 8 & 255), U2(a3, a3.gzhead.time >> 16 & 255), U2(a3, a3.gzhead.time >> 24 & 255), U2(a3, 9 === a3.level ? 2 : a3.strategy >= 2 || a3.level < 2 ? 4 : 0), U2(a3, 255 & a3.gzhead.os), a3.gzhead.extra && a3.gzhead.extra.length && (U2(a3, 255 & a3.gzhead.extra.length), U2(a3, a3.gzhead.extra.length >> 8 & 255)), a3.gzhead.hcrc && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending, 0)), a3.gzindex = 0, a3.status = 69) : (U2(a3, 0), U2(a3, 0), U2(a3, 0), U2(a3, 0), U2(a3, 0), U2(a3, 9 === a3.level ? 2 : a3.strategy >= 2 || a3.level < 2 ? 4 : 0), U2(a3, 3), a3.status = k2);
    else {
      var c3 = B2 + (a3.w_bits - 8 << 4) << 8;
      c3 |= (a3.strategy >= 2 || a3.level < 2 ? 0 : a3.level < 6 ? 1 : 6 === a3.level ? 2 : 3) << 6, 0 !== a3.strstart && (c3 |= 32), c3 += 31 - c3 % 31, a3.status = k2, O2(a3, c3), 0 !== a3.strstart && (O2(a3, e3.adler >>> 16), O2(a3, 65535 & e3.adler)), e3.adler = 1;
    }
    if (69 === a3.status) if (a3.gzhead.extra) {
      for (r3 = a3.pending; a3.gzindex < (65535 & a3.gzhead.extra.length) && (a3.pending !== a3.pending_buf_size || (a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), R2(e3), r3 = a3.pending, a3.pending !== a3.pending_buf_size)); ) U2(a3, 255 & a3.gzhead.extra[a3.gzindex]), a3.gzindex++;
      a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), a3.gzindex === a3.gzhead.extra.length && (a3.gzindex = 0, a3.status = 73);
    } else a3.status = 73;
    if (73 === a3.status) if (a3.gzhead.name) {
      r3 = a3.pending;
      do {
        if (a3.pending === a3.pending_buf_size && (a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), R2(e3), r3 = a3.pending, a3.pending === a3.pending_buf_size)) {
          o3 = 1;
          break;
        }
        o3 = a3.gzindex < a3.gzhead.name.length ? 255 & a3.gzhead.name.charCodeAt(a3.gzindex++) : 0, U2(a3, o3);
      } while (0 !== o3);
      a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), 0 === o3 && (a3.gzindex = 0, a3.status = 91);
    } else a3.status = 91;
    if (91 === a3.status) if (a3.gzhead.comment) {
      r3 = a3.pending;
      do {
        if (a3.pending === a3.pending_buf_size && (a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), R2(e3), r3 = a3.pending, a3.pending === a3.pending_buf_size)) {
          o3 = 1;
          break;
        }
        o3 = a3.gzindex < a3.gzhead.comment.length ? 255 & a3.gzhead.comment.charCodeAt(a3.gzindex++) : 0, U2(a3, o3);
      } while (0 !== o3);
      a3.gzhead.hcrc && a3.pending > r3 && (e3.adler = n2(e3.adler, a3.pending_buf, a3.pending - r3, r3)), 0 === o3 && (a3.status = b2);
    } else a3.status = b2;
    if (a3.status === b2 && (a3.gzhead.hcrc ? (a3.pending + 2 > a3.pending_buf_size && R2(e3), a3.pending + 2 <= a3.pending_buf_size && (U2(a3, 255 & e3.adler), U2(a3, e3.adler >> 8 & 255), e3.adler = 0, a3.status = k2)) : a3.status = k2), 0 !== a3.pending) {
      if (R2(e3), 0 === e3.avail_out) return a3.last_flush = -1, d2;
    } else if (0 === e3.avail_in && T2(t2) <= T2(A3) && t2 !== g2) return G2(e3, -5);
    if (a3.status === D2 && 0 !== e3.avail_in) return G2(e3, -5);
    if (0 !== e3.avail_in || 0 !== a3.lookahead || t2 !== l2 && a3.status !== D2) {
      var I3 = 2 === a3.strategy ? function(e4, t3) {
        for (var A4; ; ) {
          if (0 === e4.lookahead && (j2(e4), 0 === e4.lookahead)) {
            if (t3 === l2) return x2;
            break;
          }
          if (e4.match_length = 0, A4 = s2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, A4 && (M2(e4, false), 0 === e4.strm.avail_out)) return x2;
        }
        return e4.insert = 0, t3 === g2 ? (M2(e4, true), 0 === e4.strm.avail_out ? S2 : F2) : e4.last_lit && (M2(e4, false), 0 === e4.strm.avail_out) ? x2 : L2;
      }(a3, t2) : 3 === a3.strategy ? function(e4, t3) {
        for (var A4, i3, a4, r4, n3 = e4.window; ; ) {
          if (e4.lookahead <= w2) {
            if (j2(e4), e4.lookahead <= w2 && t3 === l2) return x2;
            if (0 === e4.lookahead) break;
          }
          if (e4.match_length = 0, e4.lookahead >= y2 && e4.strstart > 0 && (i3 = n3[a4 = e4.strstart - 1]) === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4]) {
            r4 = e4.strstart + w2;
            do {
            } while (i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && i3 === n3[++a4] && a4 < r4);
            e4.match_length = w2 - (r4 - a4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
          }
          if (e4.match_length >= y2 ? (A4 = s2._tr_tally(e4, 1, e4.match_length - y2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (A4 = s2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), A4 && (M2(e4, false), 0 === e4.strm.avail_out)) return x2;
        }
        return e4.insert = 0, t3 === g2 ? (M2(e4, true), 0 === e4.strm.avail_out ? S2 : F2) : e4.last_lit && (M2(e4, false), 0 === e4.strm.avail_out) ? x2 : L2;
      }(a3, t2) : i2[a3.level].func(a3, t2);
      if (I3 !== S2 && I3 !== F2 || (a3.status = D2), I3 === x2 || I3 === S2) return 0 === e3.avail_out && (a3.last_flush = -1), d2;
      if (I3 === L2 && (1 === t2 ? s2._tr_align(a3) : 5 !== t2 && (s2._tr_stored_block(a3, 0, 0, false), 3 === t2 && (N2(a3.head), 0 === a3.lookahead && (a3.strstart = 0, a3.block_start = 0, a3.insert = 0))), R2(e3), 0 === e3.avail_out)) return a3.last_flush = -1, d2;
    }
    return t2 !== g2 ? d2 : a3.wrap <= 0 ? 1 : (2 === a3.wrap ? (U2(a3, 255 & e3.adler), U2(a3, e3.adler >> 8 & 255), U2(a3, e3.adler >> 16 & 255), U2(a3, e3.adler >> 24 & 255), U2(a3, 255 & e3.total_in), U2(a3, e3.total_in >> 8 & 255), U2(a3, e3.total_in >> 16 & 255), U2(a3, e3.total_in >> 24 & 255)) : (O2(a3, e3.adler >>> 16), O2(a3, 65535 & e3.adler)), R2(e3), a3.wrap > 0 && (a3.wrap = -a3.wrap), 0 !== a3.pending ? d2 : 1);
  }, t.deflateEnd = function(e3) {
    var t2;
    return e3 && e3.state ? (t2 = e3.state.status) !== v2 && 69 !== t2 && 73 !== t2 && 91 !== t2 && t2 !== b2 && t2 !== k2 && t2 !== D2 ? G2(e3, h2) : (e3.state = null, t2 === k2 ? G2(e3, -3) : d2) : h2;
  }, t.deflateSetDictionary = function(e3, t2) {
    var A3, i3, s3, n3, o3, l3, g3, c3, I3 = t2.length;
    if (!e3 || !e3.state) return h2;
    if (2 === (n3 = (A3 = e3.state).wrap) || 1 === n3 && A3.status !== v2 || A3.lookahead) return h2;
    for (1 === n3 && (e3.adler = r2(e3.adler, t2, I3, 0)), A3.wrap = 0, I3 >= A3.w_size && (0 === n3 && (N2(A3.head), A3.strstart = 0, A3.block_start = 0, A3.insert = 0), c3 = new a2.Buf8(A3.w_size), a2.arraySet(c3, t2, I3 - A3.w_size, A3.w_size, 0), t2 = c3, I3 = A3.w_size), o3 = e3.avail_in, l3 = e3.next_in, g3 = e3.input, e3.avail_in = I3, e3.next_in = 0, e3.input = t2, j2(A3); A3.lookahead >= y2; ) {
      i3 = A3.strstart, s3 = A3.lookahead - (y2 - 1);
      do {
        A3.ins_h = (A3.ins_h << A3.hash_shift ^ A3.window[i3 + y2 - 1]) & A3.hash_mask, A3.prev[i3 & A3.w_mask] = A3.head[A3.ins_h], A3.head[A3.ins_h] = i3, i3++;
      } while (--s3);
      A3.strstart = i3, A3.lookahead = y2 - 1, j2(A3);
    }
    return A3.strstart += A3.lookahead, A3.block_start = A3.strstart, A3.insert = A3.lookahead, A3.lookahead = 0, A3.match_length = A3.prev_length = y2 - 1, A3.match_available = 0, e3.next_in = l3, e3.input = g3, e3.avail_in = o3, A3.wrap = n3, d2;
  }, t.deflateInfo = "pako deflate (from Nodeca project)";
}, 414: (e2) => {
  e2.exports = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  };
}, 293: (e2) => {
  e2.exports = function(e3, t) {
    var A2, i2, a2, s2, r2, n2, o2, l2, g2, d2, h2, c2, I2, u2, B2, C2, p2, f2, Q2, E2, m2, y2, w2, _2, v2;
    A2 = e3.state, i2 = e3.next_in, _2 = e3.input, a2 = i2 + (e3.avail_in - 5), s2 = e3.next_out, v2 = e3.output, r2 = s2 - (t - e3.avail_out), n2 = s2 + (e3.avail_out - 257), o2 = A2.dmax, l2 = A2.wsize, g2 = A2.whave, d2 = A2.wnext, h2 = A2.window, c2 = A2.hold, I2 = A2.bits, u2 = A2.lencode, B2 = A2.distcode, C2 = (1 << A2.lenbits) - 1, p2 = (1 << A2.distbits) - 1;
    e: do {
      I2 < 15 && (c2 += _2[i2++] << I2, I2 += 8, c2 += _2[i2++] << I2, I2 += 8), f2 = u2[c2 & C2];
      t: for (; ; ) {
        if (c2 >>>= Q2 = f2 >>> 24, I2 -= Q2, 0 === (Q2 = f2 >>> 16 & 255)) v2[s2++] = 65535 & f2;
        else {
          if (!(16 & Q2)) {
            if (0 == (64 & Q2)) {
              f2 = u2[(65535 & f2) + (c2 & (1 << Q2) - 1)];
              continue t;
            }
            if (32 & Q2) {
              A2.mode = 12;
              break e;
            }
            e3.msg = "invalid literal/length code", A2.mode = 30;
            break e;
          }
          E2 = 65535 & f2, (Q2 &= 15) && (I2 < Q2 && (c2 += _2[i2++] << I2, I2 += 8), E2 += c2 & (1 << Q2) - 1, c2 >>>= Q2, I2 -= Q2), I2 < 15 && (c2 += _2[i2++] << I2, I2 += 8, c2 += _2[i2++] << I2, I2 += 8), f2 = B2[c2 & p2];
          A: for (; ; ) {
            if (c2 >>>= Q2 = f2 >>> 24, I2 -= Q2, !(16 & (Q2 = f2 >>> 16 & 255))) {
              if (0 == (64 & Q2)) {
                f2 = B2[(65535 & f2) + (c2 & (1 << Q2) - 1)];
                continue A;
              }
              e3.msg = "invalid distance code", A2.mode = 30;
              break e;
            }
            if (m2 = 65535 & f2, I2 < (Q2 &= 15) && (c2 += _2[i2++] << I2, (I2 += 8) < Q2 && (c2 += _2[i2++] << I2, I2 += 8)), (m2 += c2 & (1 << Q2) - 1) > o2) {
              e3.msg = "invalid distance too far back", A2.mode = 30;
              break e;
            }
            if (c2 >>>= Q2, I2 -= Q2, m2 > (Q2 = s2 - r2)) {
              if ((Q2 = m2 - Q2) > g2 && A2.sane) {
                e3.msg = "invalid distance too far back", A2.mode = 30;
                break e;
              }
              if (y2 = 0, w2 = h2, 0 === d2) {
                if (y2 += l2 - Q2, Q2 < E2) {
                  E2 -= Q2;
                  do {
                    v2[s2++] = h2[y2++];
                  } while (--Q2);
                  y2 = s2 - m2, w2 = v2;
                }
              } else if (d2 < Q2) {
                if (y2 += l2 + d2 - Q2, (Q2 -= d2) < E2) {
                  E2 -= Q2;
                  do {
                    v2[s2++] = h2[y2++];
                  } while (--Q2);
                  if (y2 = 0, d2 < E2) {
                    E2 -= Q2 = d2;
                    do {
                      v2[s2++] = h2[y2++];
                    } while (--Q2);
                    y2 = s2 - m2, w2 = v2;
                  }
                }
              } else if (y2 += d2 - Q2, Q2 < E2) {
                E2 -= Q2;
                do {
                  v2[s2++] = h2[y2++];
                } while (--Q2);
                y2 = s2 - m2, w2 = v2;
              }
              for (; E2 > 2; ) v2[s2++] = w2[y2++], v2[s2++] = w2[y2++], v2[s2++] = w2[y2++], E2 -= 3;
              E2 && (v2[s2++] = w2[y2++], E2 > 1 && (v2[s2++] = w2[y2++]));
            } else {
              y2 = s2 - m2;
              do {
                v2[s2++] = v2[y2++], v2[s2++] = v2[y2++], v2[s2++] = v2[y2++], E2 -= 3;
              } while (E2 > 2);
              E2 && (v2[s2++] = v2[y2++], E2 > 1 && (v2[s2++] = v2[y2++]));
            }
            break;
          }
        }
        break;
      }
    } while (i2 < a2 && s2 < n2);
    i2 -= E2 = I2 >> 3, c2 &= (1 << (I2 -= E2 << 3)) - 1, e3.next_in = i2, e3.next_out = s2, e3.avail_in = i2 < a2 ? a2 - i2 + 5 : 5 - (i2 - a2), e3.avail_out = s2 < n2 ? n2 - s2 + 257 : 257 - (s2 - n2), A2.hold = c2, A2.bits = I2;
  };
}, 447: (e2, t, A2) => {
  var i2 = A2(805), a2 = A2(269), s2 = A2(823), r2 = A2(293), n2 = A2(998), o2 = 1, l2 = 2, g2 = 0, d2 = -2, h2 = 1, c2 = 12, I2 = 30, u2 = 852, B2 = 592;
  function C2(e3) {
    return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
  }
  function p2() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new i2.Buf16(320), this.work = new i2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function f2(e3) {
    var t2;
    return e3 && e3.state ? (t2 = e3.state, e3.total_in = e3.total_out = t2.total = 0, e3.msg = "", t2.wrap && (e3.adler = 1 & t2.wrap), t2.mode = h2, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new i2.Buf32(u2), t2.distcode = t2.distdyn = new i2.Buf32(B2), t2.sane = 1, t2.back = -1, g2) : d2;
  }
  function Q2(e3) {
    var t2;
    return e3 && e3.state ? ((t2 = e3.state).wsize = 0, t2.whave = 0, t2.wnext = 0, f2(e3)) : d2;
  }
  function E2(e3, t2) {
    var A3, i3;
    return e3 && e3.state ? (i3 = e3.state, t2 < 0 ? (A3 = 0, t2 = -t2) : (A3 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? d2 : (null !== i3.window && i3.wbits !== t2 && (i3.window = null), i3.wrap = A3, i3.wbits = t2, Q2(e3))) : d2;
  }
  function m2(e3, t2) {
    var A3, i3;
    return e3 ? (i3 = new p2(), e3.state = i3, i3.window = null, (A3 = E2(e3, t2)) !== g2 && (e3.state = null), A3) : d2;
  }
  var y2, w2, _2 = true;
  function v2(e3) {
    if (_2) {
      var t2;
      for (y2 = new i2.Buf32(512), w2 = new i2.Buf32(32), t2 = 0; t2 < 144; ) e3.lens[t2++] = 8;
      for (; t2 < 256; ) e3.lens[t2++] = 9;
      for (; t2 < 280; ) e3.lens[t2++] = 7;
      for (; t2 < 288; ) e3.lens[t2++] = 8;
      for (n2(o2, e3.lens, 0, 288, y2, 0, e3.work, { bits: 9 }), t2 = 0; t2 < 32; ) e3.lens[t2++] = 5;
      n2(l2, e3.lens, 0, 32, w2, 0, e3.work, { bits: 5 }), _2 = false;
    }
    e3.lencode = y2, e3.lenbits = 9, e3.distcode = w2, e3.distbits = 5;
  }
  function b2(e3, t2, A3, a3) {
    var s3, r3 = e3.state;
    return null === r3.window && (r3.wsize = 1 << r3.wbits, r3.wnext = 0, r3.whave = 0, r3.window = new i2.Buf8(r3.wsize)), a3 >= r3.wsize ? (i2.arraySet(r3.window, t2, A3 - r3.wsize, r3.wsize, 0), r3.wnext = 0, r3.whave = r3.wsize) : ((s3 = r3.wsize - r3.wnext) > a3 && (s3 = a3), i2.arraySet(r3.window, t2, A3 - a3, s3, r3.wnext), (a3 -= s3) ? (i2.arraySet(r3.window, t2, A3 - a3, a3, 0), r3.wnext = a3, r3.whave = r3.wsize) : (r3.wnext += s3, r3.wnext === r3.wsize && (r3.wnext = 0), r3.whave < r3.wsize && (r3.whave += s3))), 0;
  }
  t.inflateReset = Q2, t.inflateReset2 = E2, t.inflateResetKeep = f2, t.inflateInit = function(e3) {
    return m2(e3, 15);
  }, t.inflateInit2 = m2, t.inflate = function(e3, t2) {
    var A3, u3, B3, p3, f3, Q3, E3, m3, y3, w3, _3, k2, D2, x2, L2, S2, F2, G2, T2, N2, R2, M2, U2, O2, q2 = 0, j2 = new i2.Buf8(4), J2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in) return d2;
    (A3 = e3.state).mode === c2 && (A3.mode = 13), f3 = e3.next_out, B3 = e3.output, E3 = e3.avail_out, p3 = e3.next_in, u3 = e3.input, Q3 = e3.avail_in, m3 = A3.hold, y3 = A3.bits, w3 = Q3, _3 = E3, M2 = g2;
    e: for (; ; ) switch (A3.mode) {
      case h2:
        if (0 === A3.wrap) {
          A3.mode = 13;
          break;
        }
        for (; y3 < 16; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if (2 & A3.wrap && 35615 === m3) {
          A3.check = 0, j2[0] = 255 & m3, j2[1] = m3 >>> 8 & 255, A3.check = s2(A3.check, j2, 2, 0), m3 = 0, y3 = 0, A3.mode = 2;
          break;
        }
        if (A3.flags = 0, A3.head && (A3.head.done = false), !(1 & A3.wrap) || (((255 & m3) << 8) + (m3 >> 8)) % 31) {
          e3.msg = "incorrect header check", A3.mode = I2;
          break;
        }
        if (8 != (15 & m3)) {
          e3.msg = "unknown compression method", A3.mode = I2;
          break;
        }
        if (y3 -= 4, R2 = 8 + (15 & (m3 >>>= 4)), 0 === A3.wbits) A3.wbits = R2;
        else if (R2 > A3.wbits) {
          e3.msg = "invalid window size", A3.mode = I2;
          break;
        }
        A3.dmax = 1 << R2, e3.adler = A3.check = 1, A3.mode = 512 & m3 ? 10 : c2, m3 = 0, y3 = 0;
        break;
      case 2:
        for (; y3 < 16; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if (A3.flags = m3, 8 != (255 & A3.flags)) {
          e3.msg = "unknown compression method", A3.mode = I2;
          break;
        }
        if (57344 & A3.flags) {
          e3.msg = "unknown header flags set", A3.mode = I2;
          break;
        }
        A3.head && (A3.head.text = m3 >> 8 & 1), 512 & A3.flags && (j2[0] = 255 & m3, j2[1] = m3 >>> 8 & 255, A3.check = s2(A3.check, j2, 2, 0)), m3 = 0, y3 = 0, A3.mode = 3;
      case 3:
        for (; y3 < 32; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        A3.head && (A3.head.time = m3), 512 & A3.flags && (j2[0] = 255 & m3, j2[1] = m3 >>> 8 & 255, j2[2] = m3 >>> 16 & 255, j2[3] = m3 >>> 24 & 255, A3.check = s2(A3.check, j2, 4, 0)), m3 = 0, y3 = 0, A3.mode = 4;
      case 4:
        for (; y3 < 16; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        A3.head && (A3.head.xflags = 255 & m3, A3.head.os = m3 >> 8), 512 & A3.flags && (j2[0] = 255 & m3, j2[1] = m3 >>> 8 & 255, A3.check = s2(A3.check, j2, 2, 0)), m3 = 0, y3 = 0, A3.mode = 5;
      case 5:
        if (1024 & A3.flags) {
          for (; y3 < 16; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          A3.length = m3, A3.head && (A3.head.extra_len = m3), 512 & A3.flags && (j2[0] = 255 & m3, j2[1] = m3 >>> 8 & 255, A3.check = s2(A3.check, j2, 2, 0)), m3 = 0, y3 = 0;
        } else A3.head && (A3.head.extra = null);
        A3.mode = 6;
      case 6:
        if (1024 & A3.flags && ((k2 = A3.length) > Q3 && (k2 = Q3), k2 && (A3.head && (R2 = A3.head.extra_len - A3.length, A3.head.extra || (A3.head.extra = new Array(A3.head.extra_len)), i2.arraySet(A3.head.extra, u3, p3, k2, R2)), 512 & A3.flags && (A3.check = s2(A3.check, u3, k2, p3)), Q3 -= k2, p3 += k2, A3.length -= k2), A3.length)) break e;
        A3.length = 0, A3.mode = 7;
      case 7:
        if (2048 & A3.flags) {
          if (0 === Q3) break e;
          k2 = 0;
          do {
            R2 = u3[p3 + k2++], A3.head && R2 && A3.length < 65536 && (A3.head.name += String.fromCharCode(R2));
          } while (R2 && k2 < Q3);
          if (512 & A3.flags && (A3.check = s2(A3.check, u3, k2, p3)), Q3 -= k2, p3 += k2, R2) break e;
        } else A3.head && (A3.head.name = null);
        A3.length = 0, A3.mode = 8;
      case 8:
        if (4096 & A3.flags) {
          if (0 === Q3) break e;
          k2 = 0;
          do {
            R2 = u3[p3 + k2++], A3.head && R2 && A3.length < 65536 && (A3.head.comment += String.fromCharCode(R2));
          } while (R2 && k2 < Q3);
          if (512 & A3.flags && (A3.check = s2(A3.check, u3, k2, p3)), Q3 -= k2, p3 += k2, R2) break e;
        } else A3.head && (A3.head.comment = null);
        A3.mode = 9;
      case 9:
        if (512 & A3.flags) {
          for (; y3 < 16; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          if (m3 !== (65535 & A3.check)) {
            e3.msg = "header crc mismatch", A3.mode = I2;
            break;
          }
          m3 = 0, y3 = 0;
        }
        A3.head && (A3.head.hcrc = A3.flags >> 9 & 1, A3.head.done = true), e3.adler = A3.check = 0, A3.mode = c2;
        break;
      case 10:
        for (; y3 < 32; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        e3.adler = A3.check = C2(m3), m3 = 0, y3 = 0, A3.mode = 11;
      case 11:
        if (0 === A3.havedict) return e3.next_out = f3, e3.avail_out = E3, e3.next_in = p3, e3.avail_in = Q3, A3.hold = m3, A3.bits = y3, 2;
        e3.adler = A3.check = 1, A3.mode = c2;
      case c2:
        if (5 === t2 || 6 === t2) break e;
      case 13:
        if (A3.last) {
          m3 >>>= 7 & y3, y3 -= 7 & y3, A3.mode = 27;
          break;
        }
        for (; y3 < 3; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        switch (A3.last = 1 & m3, y3 -= 1, 3 & (m3 >>>= 1)) {
          case 0:
            A3.mode = 14;
            break;
          case 1:
            if (v2(A3), A3.mode = 20, 6 === t2) {
              m3 >>>= 2, y3 -= 2;
              break e;
            }
            break;
          case 2:
            A3.mode = 17;
            break;
          case 3:
            e3.msg = "invalid block type", A3.mode = I2;
        }
        m3 >>>= 2, y3 -= 2;
        break;
      case 14:
        for (m3 >>>= 7 & y3, y3 -= 7 & y3; y3 < 32; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if ((65535 & m3) != (m3 >>> 16 ^ 65535)) {
          e3.msg = "invalid stored block lengths", A3.mode = I2;
          break;
        }
        if (A3.length = 65535 & m3, m3 = 0, y3 = 0, A3.mode = 15, 6 === t2) break e;
      case 15:
        A3.mode = 16;
      case 16:
        if (k2 = A3.length) {
          if (k2 > Q3 && (k2 = Q3), k2 > E3 && (k2 = E3), 0 === k2) break e;
          i2.arraySet(B3, u3, p3, k2, f3), Q3 -= k2, p3 += k2, E3 -= k2, f3 += k2, A3.length -= k2;
          break;
        }
        A3.mode = c2;
        break;
      case 17:
        for (; y3 < 14; ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if (A3.nlen = 257 + (31 & m3), m3 >>>= 5, y3 -= 5, A3.ndist = 1 + (31 & m3), m3 >>>= 5, y3 -= 5, A3.ncode = 4 + (15 & m3), m3 >>>= 4, y3 -= 4, A3.nlen > 286 || A3.ndist > 30) {
          e3.msg = "too many length or distance symbols", A3.mode = I2;
          break;
        }
        A3.have = 0, A3.mode = 18;
      case 18:
        for (; A3.have < A3.ncode; ) {
          for (; y3 < 3; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          A3.lens[J2[A3.have++]] = 7 & m3, m3 >>>= 3, y3 -= 3;
        }
        for (; A3.have < 19; ) A3.lens[J2[A3.have++]] = 0;
        if (A3.lencode = A3.lendyn, A3.lenbits = 7, U2 = { bits: A3.lenbits }, M2 = n2(0, A3.lens, 0, 19, A3.lencode, 0, A3.work, U2), A3.lenbits = U2.bits, M2) {
          e3.msg = "invalid code lengths set", A3.mode = I2;
          break;
        }
        A3.have = 0, A3.mode = 19;
      case 19:
        for (; A3.have < A3.nlen + A3.ndist; ) {
          for (; S2 = (q2 = A3.lencode[m3 & (1 << A3.lenbits) - 1]) >>> 16 & 255, F2 = 65535 & q2, !((L2 = q2 >>> 24) <= y3); ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          if (F2 < 16) m3 >>>= L2, y3 -= L2, A3.lens[A3.have++] = F2;
          else {
            if (16 === F2) {
              for (O2 = L2 + 2; y3 < O2; ) {
                if (0 === Q3) break e;
                Q3--, m3 += u3[p3++] << y3, y3 += 8;
              }
              if (m3 >>>= L2, y3 -= L2, 0 === A3.have) {
                e3.msg = "invalid bit length repeat", A3.mode = I2;
                break;
              }
              R2 = A3.lens[A3.have - 1], k2 = 3 + (3 & m3), m3 >>>= 2, y3 -= 2;
            } else if (17 === F2) {
              for (O2 = L2 + 3; y3 < O2; ) {
                if (0 === Q3) break e;
                Q3--, m3 += u3[p3++] << y3, y3 += 8;
              }
              y3 -= L2, R2 = 0, k2 = 3 + (7 & (m3 >>>= L2)), m3 >>>= 3, y3 -= 3;
            } else {
              for (O2 = L2 + 7; y3 < O2; ) {
                if (0 === Q3) break e;
                Q3--, m3 += u3[p3++] << y3, y3 += 8;
              }
              y3 -= L2, R2 = 0, k2 = 11 + (127 & (m3 >>>= L2)), m3 >>>= 7, y3 -= 7;
            }
            if (A3.have + k2 > A3.nlen + A3.ndist) {
              e3.msg = "invalid bit length repeat", A3.mode = I2;
              break;
            }
            for (; k2--; ) A3.lens[A3.have++] = R2;
          }
        }
        if (A3.mode === I2) break;
        if (0 === A3.lens[256]) {
          e3.msg = "invalid code -- missing end-of-block", A3.mode = I2;
          break;
        }
        if (A3.lenbits = 9, U2 = { bits: A3.lenbits }, M2 = n2(o2, A3.lens, 0, A3.nlen, A3.lencode, 0, A3.work, U2), A3.lenbits = U2.bits, M2) {
          e3.msg = "invalid literal/lengths set", A3.mode = I2;
          break;
        }
        if (A3.distbits = 6, A3.distcode = A3.distdyn, U2 = { bits: A3.distbits }, M2 = n2(l2, A3.lens, A3.nlen, A3.ndist, A3.distcode, 0, A3.work, U2), A3.distbits = U2.bits, M2) {
          e3.msg = "invalid distances set", A3.mode = I2;
          break;
        }
        if (A3.mode = 20, 6 === t2) break e;
      case 20:
        A3.mode = 21;
      case 21:
        if (Q3 >= 6 && E3 >= 258) {
          e3.next_out = f3, e3.avail_out = E3, e3.next_in = p3, e3.avail_in = Q3, A3.hold = m3, A3.bits = y3, r2(e3, _3), f3 = e3.next_out, B3 = e3.output, E3 = e3.avail_out, p3 = e3.next_in, u3 = e3.input, Q3 = e3.avail_in, m3 = A3.hold, y3 = A3.bits, A3.mode === c2 && (A3.back = -1);
          break;
        }
        for (A3.back = 0; S2 = (q2 = A3.lencode[m3 & (1 << A3.lenbits) - 1]) >>> 16 & 255, F2 = 65535 & q2, !((L2 = q2 >>> 24) <= y3); ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if (S2 && 0 == (240 & S2)) {
          for (G2 = L2, T2 = S2, N2 = F2; S2 = (q2 = A3.lencode[N2 + ((m3 & (1 << G2 + T2) - 1) >> G2)]) >>> 16 & 255, F2 = 65535 & q2, !(G2 + (L2 = q2 >>> 24) <= y3); ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          m3 >>>= G2, y3 -= G2, A3.back += G2;
        }
        if (m3 >>>= L2, y3 -= L2, A3.back += L2, A3.length = F2, 0 === S2) {
          A3.mode = 26;
          break;
        }
        if (32 & S2) {
          A3.back = -1, A3.mode = c2;
          break;
        }
        if (64 & S2) {
          e3.msg = "invalid literal/length code", A3.mode = I2;
          break;
        }
        A3.extra = 15 & S2, A3.mode = 22;
      case 22:
        if (A3.extra) {
          for (O2 = A3.extra; y3 < O2; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          A3.length += m3 & (1 << A3.extra) - 1, m3 >>>= A3.extra, y3 -= A3.extra, A3.back += A3.extra;
        }
        A3.was = A3.length, A3.mode = 23;
      case 23:
        for (; S2 = (q2 = A3.distcode[m3 & (1 << A3.distbits) - 1]) >>> 16 & 255, F2 = 65535 & q2, !((L2 = q2 >>> 24) <= y3); ) {
          if (0 === Q3) break e;
          Q3--, m3 += u3[p3++] << y3, y3 += 8;
        }
        if (0 == (240 & S2)) {
          for (G2 = L2, T2 = S2, N2 = F2; S2 = (q2 = A3.distcode[N2 + ((m3 & (1 << G2 + T2) - 1) >> G2)]) >>> 16 & 255, F2 = 65535 & q2, !(G2 + (L2 = q2 >>> 24) <= y3); ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          m3 >>>= G2, y3 -= G2, A3.back += G2;
        }
        if (m3 >>>= L2, y3 -= L2, A3.back += L2, 64 & S2) {
          e3.msg = "invalid distance code", A3.mode = I2;
          break;
        }
        A3.offset = F2, A3.extra = 15 & S2, A3.mode = 24;
      case 24:
        if (A3.extra) {
          for (O2 = A3.extra; y3 < O2; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          A3.offset += m3 & (1 << A3.extra) - 1, m3 >>>= A3.extra, y3 -= A3.extra, A3.back += A3.extra;
        }
        if (A3.offset > A3.dmax) {
          e3.msg = "invalid distance too far back", A3.mode = I2;
          break;
        }
        A3.mode = 25;
      case 25:
        if (0 === E3) break e;
        if (k2 = _3 - E3, A3.offset > k2) {
          if ((k2 = A3.offset - k2) > A3.whave && A3.sane) {
            e3.msg = "invalid distance too far back", A3.mode = I2;
            break;
          }
          k2 > A3.wnext ? (k2 -= A3.wnext, D2 = A3.wsize - k2) : D2 = A3.wnext - k2, k2 > A3.length && (k2 = A3.length), x2 = A3.window;
        } else x2 = B3, D2 = f3 - A3.offset, k2 = A3.length;
        k2 > E3 && (k2 = E3), E3 -= k2, A3.length -= k2;
        do {
          B3[f3++] = x2[D2++];
        } while (--k2);
        0 === A3.length && (A3.mode = 21);
        break;
      case 26:
        if (0 === E3) break e;
        B3[f3++] = A3.length, E3--, A3.mode = 21;
        break;
      case 27:
        if (A3.wrap) {
          for (; y3 < 32; ) {
            if (0 === Q3) break e;
            Q3--, m3 |= u3[p3++] << y3, y3 += 8;
          }
          if (_3 -= E3, e3.total_out += _3, A3.total += _3, _3 && (e3.adler = A3.check = A3.flags ? s2(A3.check, B3, _3, f3 - _3) : a2(A3.check, B3, _3, f3 - _3)), _3 = E3, (A3.flags ? m3 : C2(m3)) !== A3.check) {
            e3.msg = "incorrect data check", A3.mode = I2;
            break;
          }
          m3 = 0, y3 = 0;
        }
        A3.mode = 28;
      case 28:
        if (A3.wrap && A3.flags) {
          for (; y3 < 32; ) {
            if (0 === Q3) break e;
            Q3--, m3 += u3[p3++] << y3, y3 += 8;
          }
          if (m3 !== (4294967295 & A3.total)) {
            e3.msg = "incorrect length check", A3.mode = I2;
            break;
          }
          m3 = 0, y3 = 0;
        }
        A3.mode = 29;
      case 29:
        M2 = 1;
        break e;
      case I2:
        M2 = -3;
        break e;
      case 31:
        return -4;
      default:
        return d2;
    }
    return e3.next_out = f3, e3.avail_out = E3, e3.next_in = p3, e3.avail_in = Q3, A3.hold = m3, A3.bits = y3, (A3.wsize || _3 !== e3.avail_out && A3.mode < I2 && (A3.mode < 27 || 4 !== t2)) && b2(e3, e3.output, e3.next_out, _3 - e3.avail_out) ? (A3.mode = 31, -4) : (w3 -= e3.avail_in, _3 -= e3.avail_out, e3.total_in += w3, e3.total_out += _3, A3.total += _3, A3.wrap && _3 && (e3.adler = A3.check = A3.flags ? s2(A3.check, B3, _3, e3.next_out - _3) : a2(A3.check, B3, _3, e3.next_out - _3)), e3.data_type = A3.bits + (A3.last ? 64 : 0) + (A3.mode === c2 ? 128 : 0) + (20 === A3.mode || 15 === A3.mode ? 256 : 0), (0 === w3 && 0 === _3 || 4 === t2) && M2 === g2 && (M2 = -5), M2);
  }, t.inflateEnd = function(e3) {
    if (!e3 || !e3.state) return d2;
    var t2 = e3.state;
    return t2.window && (t2.window = null), e3.state = null, g2;
  }, t.inflateGetHeader = function(e3, t2) {
    var A3;
    return e3 && e3.state ? 0 == (2 & (A3 = e3.state).wrap) ? d2 : (A3.head = t2, t2.done = false, g2) : d2;
  }, t.inflateSetDictionary = function(e3, t2) {
    var A3, i3 = t2.length;
    return e3 && e3.state ? 0 !== (A3 = e3.state).wrap && 11 !== A3.mode ? d2 : 11 === A3.mode && a2(1, t2, i3, 0) !== A3.check ? -3 : b2(e3, t2, i3, i3) ? (A3.mode = 31, -4) : (A3.havedict = 1, g2) : d2;
  }, t.inflateInfo = "pako inflate (from Nodeca project)";
}, 998: (e2, t, A2) => {
  var i2 = A2(805), a2 = 15, s2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], n2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], o2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  e2.exports = function(e3, t2, A3, l2, g2, d2, h2, c2) {
    var I2, u2, B2, C2, p2, f2, Q2, E2, m2, y2 = c2.bits, w2 = 0, _2 = 0, v2 = 0, b2 = 0, k2 = 0, D2 = 0, x2 = 0, L2 = 0, S2 = 0, F2 = 0, G2 = null, T2 = 0, N2 = new i2.Buf16(16), R2 = new i2.Buf16(16), M2 = null, U2 = 0;
    for (w2 = 0; w2 <= a2; w2++) N2[w2] = 0;
    for (_2 = 0; _2 < l2; _2++) N2[t2[A3 + _2]]++;
    for (k2 = y2, b2 = a2; b2 >= 1 && 0 === N2[b2]; b2--) ;
    if (k2 > b2 && (k2 = b2), 0 === b2) return g2[d2++] = 20971520, g2[d2++] = 20971520, c2.bits = 1, 0;
    for (v2 = 1; v2 < b2 && 0 === N2[v2]; v2++) ;
    for (k2 < v2 && (k2 = v2), L2 = 1, w2 = 1; w2 <= a2; w2++) if (L2 <<= 1, (L2 -= N2[w2]) < 0) return -1;
    if (L2 > 0 && (0 === e3 || 1 !== b2)) return -1;
    for (R2[1] = 0, w2 = 1; w2 < a2; w2++) R2[w2 + 1] = R2[w2] + N2[w2];
    for (_2 = 0; _2 < l2; _2++) 0 !== t2[A3 + _2] && (h2[R2[t2[A3 + _2]]++] = _2);
    if (0 === e3 ? (G2 = M2 = h2, f2 = 19) : 1 === e3 ? (G2 = s2, T2 -= 257, M2 = r2, U2 -= 257, f2 = 256) : (G2 = n2, M2 = o2, f2 = -1), F2 = 0, _2 = 0, w2 = v2, p2 = d2, D2 = k2, x2 = 0, B2 = -1, C2 = (S2 = 1 << k2) - 1, 1 === e3 && S2 > 852 || 2 === e3 && S2 > 592) return 1;
    for (; ; ) {
      Q2 = w2 - x2, h2[_2] < f2 ? (E2 = 0, m2 = h2[_2]) : h2[_2] > f2 ? (E2 = M2[U2 + h2[_2]], m2 = G2[T2 + h2[_2]]) : (E2 = 96, m2 = 0), I2 = 1 << w2 - x2, v2 = u2 = 1 << D2;
      do {
        g2[p2 + (F2 >> x2) + (u2 -= I2)] = Q2 << 24 | E2 << 16 | m2 | 0;
      } while (0 !== u2);
      for (I2 = 1 << w2 - 1; F2 & I2; ) I2 >>= 1;
      if (0 !== I2 ? (F2 &= I2 - 1, F2 += I2) : F2 = 0, _2++, 0 == --N2[w2]) {
        if (w2 === b2) break;
        w2 = t2[A3 + h2[_2]];
      }
      if (w2 > k2 && (F2 & C2) !== B2) {
        for (0 === x2 && (x2 = k2), p2 += v2, L2 = 1 << (D2 = w2 - x2); D2 + x2 < b2 && !((L2 -= N2[D2 + x2]) <= 0); ) D2++, L2 <<= 1;
        if (S2 += 1 << D2, 1 === e3 && S2 > 852 || 2 === e3 && S2 > 592) return 1;
        g2[B2 = F2 & C2] = k2 << 24 | D2 << 16 | p2 - d2 | 0;
      }
    }
    return 0 !== F2 && (g2[p2 + F2] = w2 - x2 << 24 | 64 << 16 | 0), c2.bits = k2, 0;
  };
}, 674: (e2) => {
  e2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
}, 665: (e2, t, A2) => {
  var i2 = A2(805), a2 = 0, s2 = 1;
  function r2(e3) {
    for (var t2 = e3.length; --t2 >= 0; ) e3[t2] = 0;
  }
  var n2 = 0, o2 = 29, l2 = 256, g2 = l2 + 1 + o2, d2 = 30, h2 = 19, c2 = 2 * g2 + 1, I2 = 15, u2 = 16, B2 = 7, C2 = 256, p2 = 16, f2 = 17, Q2 = 18, E2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], m2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], y2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], w2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], _2 = new Array(2 * (g2 + 2));
  r2(_2);
  var v2 = new Array(2 * d2);
  r2(v2);
  var b2 = new Array(512);
  r2(b2);
  var k2 = new Array(256);
  r2(k2);
  var D2 = new Array(o2);
  r2(D2);
  var x2, L2, S2, F2 = new Array(d2);
  function G2(e3, t2, A3, i3, a3) {
    this.static_tree = e3, this.extra_bits = t2, this.extra_base = A3, this.elems = i3, this.max_length = a3, this.has_stree = e3 && e3.length;
  }
  function T2(e3, t2) {
    this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t2;
  }
  function N2(e3) {
    return e3 < 256 ? b2[e3] : b2[256 + (e3 >>> 7)];
  }
  function R2(e3, t2) {
    e3.pending_buf[e3.pending++] = 255 & t2, e3.pending_buf[e3.pending++] = t2 >>> 8 & 255;
  }
  function M2(e3, t2, A3) {
    e3.bi_valid > u2 - A3 ? (e3.bi_buf |= t2 << e3.bi_valid & 65535, R2(e3, e3.bi_buf), e3.bi_buf = t2 >> u2 - e3.bi_valid, e3.bi_valid += A3 - u2) : (e3.bi_buf |= t2 << e3.bi_valid & 65535, e3.bi_valid += A3);
  }
  function U2(e3, t2, A3) {
    M2(e3, A3[2 * t2], A3[2 * t2 + 1]);
  }
  function O2(e3, t2) {
    var A3 = 0;
    do {
      A3 |= 1 & e3, e3 >>>= 1, A3 <<= 1;
    } while (--t2 > 0);
    return A3 >>> 1;
  }
  function q2(e3, t2, A3) {
    var i3, a3, s3 = new Array(I2 + 1), r3 = 0;
    for (i3 = 1; i3 <= I2; i3++) s3[i3] = r3 = r3 + A3[i3 - 1] << 1;
    for (a3 = 0; a3 <= t2; a3++) {
      var n3 = e3[2 * a3 + 1];
      0 !== n3 && (e3[2 * a3] = O2(s3[n3]++, n3));
    }
  }
  function j2(e3) {
    var t2;
    for (t2 = 0; t2 < g2; t2++) e3.dyn_ltree[2 * t2] = 0;
    for (t2 = 0; t2 < d2; t2++) e3.dyn_dtree[2 * t2] = 0;
    for (t2 = 0; t2 < h2; t2++) e3.bl_tree[2 * t2] = 0;
    e3.dyn_ltree[2 * C2] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
  }
  function J2(e3) {
    e3.bi_valid > 8 ? R2(e3, e3.bi_buf) : e3.bi_valid > 0 && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
  }
  function Z2(e3, t2, A3, i3) {
    var a3 = 2 * t2, s3 = 2 * A3;
    return e3[a3] < e3[s3] || e3[a3] === e3[s3] && i3[t2] <= i3[A3];
  }
  function Y2(e3, t2, A3) {
    for (var i3 = e3.heap[A3], a3 = A3 << 1; a3 <= e3.heap_len && (a3 < e3.heap_len && Z2(t2, e3.heap[a3 + 1], e3.heap[a3], e3.depth) && a3++, !Z2(t2, i3, e3.heap[a3], e3.depth)); ) e3.heap[A3] = e3.heap[a3], A3 = a3, a3 <<= 1;
    e3.heap[A3] = i3;
  }
  function H2(e3, t2, A3) {
    var i3, a3, s3, r3, n3 = 0;
    if (0 !== e3.last_lit) do {
      i3 = e3.pending_buf[e3.d_buf + 2 * n3] << 8 | e3.pending_buf[e3.d_buf + 2 * n3 + 1], a3 = e3.pending_buf[e3.l_buf + n3], n3++, 0 === i3 ? U2(e3, a3, t2) : (U2(e3, (s3 = k2[a3]) + l2 + 1, t2), 0 !== (r3 = E2[s3]) && M2(e3, a3 -= D2[s3], r3), U2(e3, s3 = N2(--i3), A3), 0 !== (r3 = m2[s3]) && M2(e3, i3 -= F2[s3], r3));
    } while (n3 < e3.last_lit);
    U2(e3, C2, t2);
  }
  function K2(e3, t2) {
    var A3, i3, a3, s3 = t2.dyn_tree, r3 = t2.stat_desc.static_tree, n3 = t2.stat_desc.has_stree, o3 = t2.stat_desc.elems, l3 = -1;
    for (e3.heap_len = 0, e3.heap_max = c2, A3 = 0; A3 < o3; A3++) 0 !== s3[2 * A3] ? (e3.heap[++e3.heap_len] = l3 = A3, e3.depth[A3] = 0) : s3[2 * A3 + 1] = 0;
    for (; e3.heap_len < 2; ) s3[2 * (a3 = e3.heap[++e3.heap_len] = l3 < 2 ? ++l3 : 0)] = 1, e3.depth[a3] = 0, e3.opt_len--, n3 && (e3.static_len -= r3[2 * a3 + 1]);
    for (t2.max_code = l3, A3 = e3.heap_len >> 1; A3 >= 1; A3--) Y2(e3, s3, A3);
    a3 = o3;
    do {
      A3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], Y2(e3, s3, 1), i3 = e3.heap[1], e3.heap[--e3.heap_max] = A3, e3.heap[--e3.heap_max] = i3, s3[2 * a3] = s3[2 * A3] + s3[2 * i3], e3.depth[a3] = (e3.depth[A3] >= e3.depth[i3] ? e3.depth[A3] : e3.depth[i3]) + 1, s3[2 * A3 + 1] = s3[2 * i3 + 1] = a3, e3.heap[1] = a3++, Y2(e3, s3, 1);
    } while (e3.heap_len >= 2);
    e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t3) {
      var A4, i4, a4, s4, r4, n4, o4 = t3.dyn_tree, l4 = t3.max_code, g3 = t3.stat_desc.static_tree, d3 = t3.stat_desc.has_stree, h3 = t3.stat_desc.extra_bits, u3 = t3.stat_desc.extra_base, B3 = t3.stat_desc.max_length, C3 = 0;
      for (s4 = 0; s4 <= I2; s4++) e4.bl_count[s4] = 0;
      for (o4[2 * e4.heap[e4.heap_max] + 1] = 0, A4 = e4.heap_max + 1; A4 < c2; A4++) (s4 = o4[2 * o4[2 * (i4 = e4.heap[A4]) + 1] + 1] + 1) > B3 && (s4 = B3, C3++), o4[2 * i4 + 1] = s4, i4 > l4 || (e4.bl_count[s4]++, r4 = 0, i4 >= u3 && (r4 = h3[i4 - u3]), n4 = o4[2 * i4], e4.opt_len += n4 * (s4 + r4), d3 && (e4.static_len += n4 * (g3[2 * i4 + 1] + r4)));
      if (0 !== C3) {
        do {
          for (s4 = B3 - 1; 0 === e4.bl_count[s4]; ) s4--;
          e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[B3]--, C3 -= 2;
        } while (C3 > 0);
        for (s4 = B3; 0 !== s4; s4--) for (i4 = e4.bl_count[s4]; 0 !== i4; ) (a4 = e4.heap[--A4]) > l4 || (o4[2 * a4 + 1] !== s4 && (e4.opt_len += (s4 - o4[2 * a4 + 1]) * o4[2 * a4], o4[2 * a4 + 1] = s4), i4--);
      }
    }(e3, t2), q2(s3, l3, e3.bl_count);
  }
  function P2(e3, t2, A3) {
    var i3, a3, s3 = -1, r3 = t2[1], n3 = 0, o3 = 7, l3 = 4;
    for (0 === r3 && (o3 = 138, l3 = 3), t2[2 * (A3 + 1) + 1] = 65535, i3 = 0; i3 <= A3; i3++) a3 = r3, r3 = t2[2 * (i3 + 1) + 1], ++n3 < o3 && a3 === r3 || (n3 < l3 ? e3.bl_tree[2 * a3] += n3 : 0 !== a3 ? (a3 !== s3 && e3.bl_tree[2 * a3]++, e3.bl_tree[2 * p2]++) : n3 <= 10 ? e3.bl_tree[2 * f2]++ : e3.bl_tree[2 * Q2]++, n3 = 0, s3 = a3, 0 === r3 ? (o3 = 138, l3 = 3) : a3 === r3 ? (o3 = 6, l3 = 3) : (o3 = 7, l3 = 4));
  }
  function z2(e3, t2, A3) {
    var i3, a3, s3 = -1, r3 = t2[1], n3 = 0, o3 = 7, l3 = 4;
    for (0 === r3 && (o3 = 138, l3 = 3), i3 = 0; i3 <= A3; i3++) if (a3 = r3, r3 = t2[2 * (i3 + 1) + 1], !(++n3 < o3 && a3 === r3)) {
      if (n3 < l3) do {
        U2(e3, a3, e3.bl_tree);
      } while (0 != --n3);
      else 0 !== a3 ? (a3 !== s3 && (U2(e3, a3, e3.bl_tree), n3--), U2(e3, p2, e3.bl_tree), M2(e3, n3 - 3, 2)) : n3 <= 10 ? (U2(e3, f2, e3.bl_tree), M2(e3, n3 - 3, 3)) : (U2(e3, Q2, e3.bl_tree), M2(e3, n3 - 11, 7));
      n3 = 0, s3 = a3, 0 === r3 ? (o3 = 138, l3 = 3) : a3 === r3 ? (o3 = 6, l3 = 3) : (o3 = 7, l3 = 4);
    }
  }
  r2(F2);
  var V2 = false;
  function W2(e3, t2, A3, a3) {
    M2(e3, (n2 << 1) + (a3 ? 1 : 0), 3), function(e4, t3, A4, a4) {
      J2(e4), a4 && (R2(e4, A4), R2(e4, ~A4)), i2.arraySet(e4.pending_buf, e4.window, t3, A4, e4.pending), e4.pending += A4;
    }(e3, t2, A3, true);
  }
  t._tr_init = function(e3) {
    V2 || (!function() {
      var e4, t2, A3, i3, a3, s3 = new Array(I2 + 1);
      for (A3 = 0, i3 = 0; i3 < o2 - 1; i3++) for (D2[i3] = A3, e4 = 0; e4 < 1 << E2[i3]; e4++) k2[A3++] = i3;
      for (k2[A3 - 1] = i3, a3 = 0, i3 = 0; i3 < 16; i3++) for (F2[i3] = a3, e4 = 0; e4 < 1 << m2[i3]; e4++) b2[a3++] = i3;
      for (a3 >>= 7; i3 < d2; i3++) for (F2[i3] = a3 << 7, e4 = 0; e4 < 1 << m2[i3] - 7; e4++) b2[256 + a3++] = i3;
      for (t2 = 0; t2 <= I2; t2++) s3[t2] = 0;
      for (e4 = 0; e4 <= 143; ) _2[2 * e4 + 1] = 8, e4++, s3[8]++;
      for (; e4 <= 255; ) _2[2 * e4 + 1] = 9, e4++, s3[9]++;
      for (; e4 <= 279; ) _2[2 * e4 + 1] = 7, e4++, s3[7]++;
      for (; e4 <= 287; ) _2[2 * e4 + 1] = 8, e4++, s3[8]++;
      for (q2(_2, g2 + 1, s3), e4 = 0; e4 < d2; e4++) v2[2 * e4 + 1] = 5, v2[2 * e4] = O2(e4, 5);
      x2 = new G2(_2, E2, l2 + 1, g2, I2), L2 = new G2(v2, m2, 0, d2, I2), S2 = new G2(new Array(0), y2, 0, h2, B2);
    }(), V2 = true), e3.l_desc = new T2(e3.dyn_ltree, x2), e3.d_desc = new T2(e3.dyn_dtree, L2), e3.bl_desc = new T2(e3.bl_tree, S2), e3.bi_buf = 0, e3.bi_valid = 0, j2(e3);
  }, t._tr_stored_block = W2, t._tr_flush_block = function(e3, t2, A3, i3) {
    var r3, n3, o3 = 0;
    e3.level > 0 ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
      var t3, A4 = 4093624447;
      for (t3 = 0; t3 <= 31; t3++, A4 >>>= 1) if (1 & A4 && 0 !== e4.dyn_ltree[2 * t3]) return a2;
      if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26]) return s2;
      for (t3 = 32; t3 < l2; t3++) if (0 !== e4.dyn_ltree[2 * t3]) return s2;
      return a2;
    }(e3)), K2(e3, e3.l_desc), K2(e3, e3.d_desc), o3 = function(e4) {
      var t3;
      for (P2(e4, e4.dyn_ltree, e4.l_desc.max_code), P2(e4, e4.dyn_dtree, e4.d_desc.max_code), K2(e4, e4.bl_desc), t3 = h2 - 1; t3 >= 3 && 0 === e4.bl_tree[2 * w2[t3] + 1]; t3--) ;
      return e4.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
    }(e3), r3 = e3.opt_len + 3 + 7 >>> 3, (n3 = e3.static_len + 3 + 7 >>> 3) <= r3 && (r3 = n3)) : r3 = n3 = A3 + 5, A3 + 4 <= r3 && -1 !== t2 ? W2(e3, t2, A3, i3) : 4 === e3.strategy || n3 === r3 ? (M2(e3, 2 + (i3 ? 1 : 0), 3), H2(e3, _2, v2)) : (M2(e3, 4 + (i3 ? 1 : 0), 3), function(e4, t3, A4, i4) {
      var a3;
      for (M2(e4, t3 - 257, 5), M2(e4, A4 - 1, 5), M2(e4, i4 - 4, 4), a3 = 0; a3 < i4; a3++) M2(e4, e4.bl_tree[2 * w2[a3] + 1], 3);
      z2(e4, e4.dyn_ltree, t3 - 1), z2(e4, e4.dyn_dtree, A4 - 1);
    }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, o3 + 1), H2(e3, e3.dyn_ltree, e3.dyn_dtree)), j2(e3), i3 && J2(e3);
  }, t._tr_tally = function(e3, t2, A3) {
    return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t2 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t2, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & A3, e3.last_lit++, 0 === t2 ? e3.dyn_ltree[2 * A3]++ : (e3.matches++, t2--, e3.dyn_ltree[2 * (k2[A3] + l2 + 1)]++, e3.dyn_dtree[2 * N2(t2)]++), e3.last_lit === e3.lit_bufsize - 1;
  }, t._tr_align = function(e3) {
    M2(e3, 2, 3), U2(e3, C2, _2), function(e4) {
      16 === e4.bi_valid ? (R2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : e4.bi_valid >= 8 && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
    }(e3);
  };
}, 442: (e2) => {
  e2.exports = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  };
}, 371: (t) => {
  t.exports = e;
} };
var i = {};
function a(e2) {
  var t = i[e2];
  if (void 0 !== t) return t.exports;
  var s2 = i[e2] = { exports: {} };
  return A[e2](s2, s2.exports, a), s2.exports;
}
a.d = (e2, t) => {
  for (var A2 in t) a.o(t, A2) && !a.o(e2, A2) && Object.defineProperty(e2, A2, { enumerable: true, get: t[A2] });
}, a.o = (e2, t) => Object.prototype.hasOwnProperty.call(e2, t);
var s;
var r;
var n = {};
a.d(n, { XM: () => vA, Pp: () => WA, B8: () => bA, Z9: () => GA, Ms: () => SA, yO: () => FA, UZ: () => kA, fN: () => PA, _k: () => UA, J4: () => HA, bR: () => zA, tS: () => $A, Ro: () => ei, M_: () => XA, Bj: () => ii, HZ: () => KA, xn: () => ni, EY: () => VA, FA: () => ai, o4: () => oi, $u: () => li, ZR: () => cA, uE: () => pA, Bf: () => wi, xm: () => hA, OK: () => Xt, r0: () => sA, IB: () => Kt, cp: () => Ht, pE: () => dA, fO: () => lA, pf: () => si, fc: () => ri, NW: () => xA, OW: () => DA, I: () => LA, N5: () => jA, fd: () => MA, zU: () => zt, RT: () => RA, SW: () => TA, s: () => NA, mD: () => IA, wi: () => oA, tP: () => uA, YK: () => BA, Ey: () => nA, qD: () => JA, rr: () => qA, Xs: () => Pt, lj: () => ti, MB: () => Ai, hu: () => ZA, Uk: () => YA }), function(e2) {
  e2.assertEqual = (e3) => e3, e2.assertIs = function(e3) {
  }, e2.assertNever = function(e3) {
    throw new Error();
  }, e2.arrayToEnum = (e3) => {
    const t = {};
    for (const A2 of e3) t[A2] = A2;
    return t;
  }, e2.getValidEnumValues = (t) => {
    const A2 = e2.objectKeys(t).filter((e3) => "number" != typeof t[t[e3]]), i2 = {};
    for (const e3 of A2) i2[e3] = t[e3];
    return e2.objectValues(i2);
  }, e2.objectValues = (t) => e2.objectKeys(t).map(function(e3) {
    return t[e3];
  }), e2.objectKeys = "function" == typeof Object.keys ? (e3) => Object.keys(e3) : (e3) => {
    const t = [];
    for (const A2 in e3) Object.prototype.hasOwnProperty.call(e3, A2) && t.push(A2);
    return t;
  }, e2.find = (e3, t) => {
    for (const A2 of e3) if (t(A2)) return A2;
  }, e2.isInteger = "function" == typeof Number.isInteger ? (e3) => Number.isInteger(e3) : (e3) => "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3, e2.joinValues = function(e3, t = " | ") {
    return e3.map((e4) => "string" == typeof e4 ? `'${e4}'` : e4).join(t);
  }, e2.jsonStringifyReplacer = (e3, t) => "bigint" == typeof t ? t.toString() : t;
}(s || (s = {})), function(e2) {
  e2.mergeShapes = (e3, t) => ({ ...e3, ...t });
}(r || (r = {}));
var o = s.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var l = (e2) => {
  switch (typeof e2) {
    case "undefined":
      return o.undefined;
    case "string":
      return o.string;
    case "number":
      return isNaN(e2) ? o.nan : o.number;
    case "boolean":
      return o.boolean;
    case "function":
      return o.function;
    case "bigint":
      return o.bigint;
    case "symbol":
      return o.symbol;
    case "object":
      return Array.isArray(e2) ? o.array : null === e2 ? o.null : e2.then && "function" == typeof e2.then && e2.catch && "function" == typeof e2.catch ? o.promise : "undefined" != typeof Map && e2 instanceof Map ? o.map : "undefined" != typeof Set && e2 instanceof Set ? o.set : "undefined" != typeof Date && e2 instanceof Date ? o.date : o.object;
    default:
      return o.unknown;
  }
};
var g = s.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var d = class _d extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e2) {
    super(), this.issues = [], this.addIssue = (e3) => {
      this.issues = [...this.issues, e3];
    }, this.addIssues = (e3 = []) => {
      this.issues = [...this.issues, ...e3];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e2;
  }
  format(e2) {
    const t = e2 || function(e3) {
      return e3.message;
    }, A2 = { _errors: [] }, i2 = (e3) => {
      for (const a2 of e3.issues) if ("invalid_union" === a2.code) a2.unionErrors.map(i2);
      else if ("invalid_return_type" === a2.code) i2(a2.returnTypeError);
      else if ("invalid_arguments" === a2.code) i2(a2.argumentsError);
      else if (0 === a2.path.length) A2._errors.push(t(a2));
      else {
        let e4 = A2, i3 = 0;
        for (; i3 < a2.path.length; ) {
          const A3 = a2.path[i3];
          i3 === a2.path.length - 1 ? (e4[A3] = e4[A3] || { _errors: [] }, e4[A3]._errors.push(t(a2))) : e4[A3] = e4[A3] || { _errors: [] }, e4 = e4[A3], i3++;
        }
      }
    };
    return i2(this), A2;
  }
  static assert(e2) {
    if (!(e2 instanceof _d)) throw new Error(`Not a ZodError: ${e2}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, s.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return 0 === this.issues.length;
  }
  flatten(e2 = (e3) => e3.message) {
    const t = {}, A2 = [];
    for (const i2 of this.issues) i2.path.length > 0 ? (t[i2.path[0]] = t[i2.path[0]] || [], t[i2.path[0]].push(e2(i2))) : A2.push(e2(i2));
    return { formErrors: A2, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
};
d.create = (e2) => new d(e2);
var h = (e2, t) => {
  let A2;
  switch (e2.code) {
    case g.invalid_type:
      A2 = e2.received === o.undefined ? "Required" : `Expected ${e2.expected}, received ${e2.received}`;
      break;
    case g.invalid_literal:
      A2 = `Invalid literal value, expected ${JSON.stringify(e2.expected, s.jsonStringifyReplacer)}`;
      break;
    case g.unrecognized_keys:
      A2 = `Unrecognized key(s) in object: ${s.joinValues(e2.keys, ", ")}`;
      break;
    case g.invalid_union:
      A2 = "Invalid input";
      break;
    case g.invalid_union_discriminator:
      A2 = `Invalid discriminator value. Expected ${s.joinValues(e2.options)}`;
      break;
    case g.invalid_enum_value:
      A2 = `Invalid enum value. Expected ${s.joinValues(e2.options)}, received '${e2.received}'`;
      break;
    case g.invalid_arguments:
      A2 = "Invalid function arguments";
      break;
    case g.invalid_return_type:
      A2 = "Invalid function return type";
      break;
    case g.invalid_date:
      A2 = "Invalid date";
      break;
    case g.invalid_string:
      "object" == typeof e2.validation ? "includes" in e2.validation ? (A2 = `Invalid input: must include "${e2.validation.includes}"`, "number" == typeof e2.validation.position && (A2 = `${A2} at one or more positions greater than or equal to ${e2.validation.position}`)) : "startsWith" in e2.validation ? A2 = `Invalid input: must start with "${e2.validation.startsWith}"` : "endsWith" in e2.validation ? A2 = `Invalid input: must end with "${e2.validation.endsWith}"` : s.assertNever(e2.validation) : A2 = "regex" !== e2.validation ? `Invalid ${e2.validation}` : "Invalid";
      break;
    case g.too_small:
      A2 = "array" === e2.type ? `Array must contain ${e2.exact ? "exactly" : e2.inclusive ? "at least" : "more than"} ${e2.minimum} element(s)` : "string" === e2.type ? `String must contain ${e2.exact ? "exactly" : e2.inclusive ? "at least" : "over"} ${e2.minimum} character(s)` : "number" === e2.type ? `Number must be ${e2.exact ? "exactly equal to " : e2.inclusive ? "greater than or equal to " : "greater than "}${e2.minimum}` : "date" === e2.type ? `Date must be ${e2.exact ? "exactly equal to " : e2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e2.minimum))}` : "Invalid input";
      break;
    case g.too_big:
      A2 = "array" === e2.type ? `Array must contain ${e2.exact ? "exactly" : e2.inclusive ? "at most" : "less than"} ${e2.maximum} element(s)` : "string" === e2.type ? `String must contain ${e2.exact ? "exactly" : e2.inclusive ? "at most" : "under"} ${e2.maximum} character(s)` : "number" === e2.type ? `Number must be ${e2.exact ? "exactly" : e2.inclusive ? "less than or equal to" : "less than"} ${e2.maximum}` : "bigint" === e2.type ? `BigInt must be ${e2.exact ? "exactly" : e2.inclusive ? "less than or equal to" : "less than"} ${e2.maximum}` : "date" === e2.type ? `Date must be ${e2.exact ? "exactly" : e2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e2.maximum))}` : "Invalid input";
      break;
    case g.custom:
      A2 = "Invalid input";
      break;
    case g.invalid_intersection_types:
      A2 = "Intersection results could not be merged";
      break;
    case g.not_multiple_of:
      A2 = `Number must be a multiple of ${e2.multipleOf}`;
      break;
    case g.not_finite:
      A2 = "Number must be finite";
      break;
    default:
      A2 = t.defaultError, s.assertNever(e2);
  }
  return { message: A2 };
};
var c = h;
function I() {
  return c;
}
var u = (e2) => {
  const { data: t, path: A2, errorMaps: i2, issueData: a2 } = e2, s2 = [...A2, ...a2.path || []], r2 = { ...a2, path: s2 };
  if (void 0 !== a2.message) return { ...a2, path: s2, message: a2.message };
  let n2 = "";
  const o2 = i2.filter((e3) => !!e3).slice().reverse();
  for (const e3 of o2) n2 = e3(r2, { data: t, defaultError: n2 }).message;
  return { ...a2, path: s2, message: n2 };
};
function B(e2, t) {
  const A2 = I(), i2 = u({ issueData: t, data: e2.data, path: e2.path, errorMaps: [e2.common.contextualErrorMap, e2.schemaErrorMap, A2, A2 === h ? void 0 : h].filter((e3) => !!e3) });
  e2.common.issues.push(i2);
}
var C = class _C {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    "valid" === this.value && (this.value = "dirty");
  }
  abort() {
    "aborted" !== this.value && (this.value = "aborted");
  }
  static mergeArray(e2, t) {
    const A2 = [];
    for (const i2 of t) {
      if ("aborted" === i2.status) return p;
      "dirty" === i2.status && e2.dirty(), A2.push(i2.value);
    }
    return { status: e2.value, value: A2 };
  }
  static async mergeObjectAsync(e2, t) {
    const A2 = [];
    for (const e3 of t) {
      const t2 = await e3.key, i2 = await e3.value;
      A2.push({ key: t2, value: i2 });
    }
    return _C.mergeObjectSync(e2, A2);
  }
  static mergeObjectSync(e2, t) {
    const A2 = {};
    for (const i2 of t) {
      const { key: t2, value: a2 } = i2;
      if ("aborted" === t2.status) return p;
      if ("aborted" === a2.status) return p;
      "dirty" === t2.status && e2.dirty(), "dirty" === a2.status && e2.dirty(), "__proto__" === t2.value || void 0 === a2.value && !i2.alwaysSet || (A2[t2.value] = a2.value);
    }
    return { status: e2.value, value: A2 };
  }
};
var p = Object.freeze({ status: "aborted" });
var f = (e2) => ({ status: "dirty", value: e2 });
var Q = (e2) => ({ status: "valid", value: e2 });
var E = (e2) => "aborted" === e2.status;
var m = (e2) => "dirty" === e2.status;
var y = (e2) => "valid" === e2.status;
var w = (e2) => "undefined" != typeof Promise && e2 instanceof Promise;
function _(e2, t, A2, i2) {
  if ("a" === A2 && !i2) throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof t ? e2 !== t || !i2 : !t.has(e2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return "m" === A2 ? i2 : "a" === A2 ? i2.call(e2) : i2 ? i2.value : t.get(e2);
}
function v(e2, t, A2, i2, a2) {
  if ("m" === i2) throw new TypeError("Private method is not writable");
  if ("a" === i2 && !a2) throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof t ? e2 !== t || !a2 : !t.has(e2)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return "a" === i2 ? a2.call(e2, A2) : a2 ? a2.value = A2 : t.set(e2, A2), A2;
}
var b;
var k;
var D;
"function" == typeof SuppressedError && SuppressedError, function(e2) {
  e2.errToObj = (e3) => "string" == typeof e3 ? { message: e3 } : e3 || {}, e2.toString = (e3) => "string" == typeof e3 ? e3 : null == e3 ? void 0 : e3.message;
}(b || (b = {}));
var x = class {
  constructor(e2, t, A2, i2) {
    this._cachedPath = [], this.parent = e2, this.data = t, this._path = A2, this._key = i2;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var L = (e2, t) => {
  if (y(t)) return { success: true, data: t.value };
  if (!e2.common.issues.length) throw new Error("Validation failed but no issues detected.");
  return { success: false, get error() {
    if (this._error) return this._error;
    const t2 = new d(e2.common.issues);
    return this._error = t2, this._error;
  } };
};
function S(e2) {
  if (!e2) return {};
  const { errorMap: t, invalid_type_error: A2, required_error: i2, description: a2 } = e2;
  if (t && (A2 || i2)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (t) return { errorMap: t, description: a2 };
  return { errorMap: (t2, a3) => {
    var s2, r2;
    const { message: n2 } = e2;
    return "invalid_enum_value" === t2.code ? { message: null != n2 ? n2 : a3.defaultError } : void 0 === a3.data ? { message: null !== (s2 = null != n2 ? n2 : i2) && void 0 !== s2 ? s2 : a3.defaultError } : "invalid_type" !== t2.code ? { message: a3.defaultError } : { message: null !== (r2 = null != n2 ? n2 : A2) && void 0 !== r2 ? r2 : a3.defaultError };
  }, description: a2 };
}
var F = class {
  get description() {
    return this._def.description;
  }
  _getType(e2) {
    return l(e2.data);
  }
  _getOrReturnCtx(e2, t) {
    return t || { common: e2.parent.common, data: e2.data, parsedType: l(e2.data), schemaErrorMap: this._def.errorMap, path: e2.path, parent: e2.parent };
  }
  _processInputParams(e2) {
    return { status: new C(), ctx: { common: e2.parent.common, data: e2.data, parsedType: l(e2.data), schemaErrorMap: this._def.errorMap, path: e2.path, parent: e2.parent } };
  }
  _parseSync(e2) {
    const t = this._parse(e2);
    if (w(t)) throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e2) {
    const t = this._parse(e2);
    return Promise.resolve(t);
  }
  parse(e2, t) {
    const A2 = this.safeParse(e2, t);
    if (A2.success) return A2.data;
    throw A2.error;
  }
  safeParse(e2, t) {
    var A2;
    const i2 = { common: { issues: [], async: null !== (A2 = null == t ? void 0 : t.async) && void 0 !== A2 && A2, contextualErrorMap: null == t ? void 0 : t.errorMap }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: l(e2) }, a2 = this._parseSync({ data: e2, path: i2.path, parent: i2 });
    return L(i2, a2);
  }
  "~validate"(e2) {
    var t, A2;
    const i2 = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: l(e2) };
    if (!this["~standard"].async) try {
      const t2 = this._parseSync({ data: e2, path: [], parent: i2 });
      return y(t2) ? { value: t2.value } : { issues: i2.common.issues };
    } catch (e3) {
      (null === (A2 = null === (t = null == e3 ? void 0 : e3.message) || void 0 === t ? void 0 : t.toLowerCase()) || void 0 === A2 ? void 0 : A2.includes("encountered")) && (this["~standard"].async = true), i2.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: e2, path: [], parent: i2 }).then((e3) => y(e3) ? { value: e3.value } : { issues: i2.common.issues });
  }
  async parseAsync(e2, t) {
    const A2 = await this.safeParseAsync(e2, t);
    if (A2.success) return A2.data;
    throw A2.error;
  }
  async safeParseAsync(e2, t) {
    const A2 = { common: { issues: [], contextualErrorMap: null == t ? void 0 : t.errorMap, async: true }, path: (null == t ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e2, parsedType: l(e2) }, i2 = this._parse({ data: e2, path: A2.path, parent: A2 }), a2 = await (w(i2) ? i2 : Promise.resolve(i2));
    return L(A2, a2);
  }
  refine(e2, t) {
    const A2 = (e3) => "string" == typeof t || void 0 === t ? { message: t } : "function" == typeof t ? t(e3) : t;
    return this._refinement((t2, i2) => {
      const a2 = e2(t2), s2 = () => i2.addIssue({ code: g.custom, ...A2(t2) });
      return "undefined" != typeof Promise && a2 instanceof Promise ? a2.then((e3) => !!e3 || (s2(), false)) : !!a2 || (s2(), false);
    });
  }
  refinement(e2, t) {
    return this._refinement((A2, i2) => !!e2(A2) || (i2.addIssue("function" == typeof t ? t(A2, i2) : t), false));
  }
  _refinement(e2) {
    return new Fe({ schema: this, typeName: Ye.ZodEffects, effect: { type: "refinement", refinement: e2 } });
  }
  superRefine(e2) {
    return this._refinement(e2);
  }
  constructor(e2) {
    this.spa = this.safeParseAsync, this._def = e2, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (e3) => this["~validate"](e3) };
  }
  optional() {
    return Ge.create(this, this._def);
  }
  nullable() {
    return Te.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Ie.create(this);
  }
  promise() {
    return Se.create(this, this._def);
  }
  or(e2) {
    return Ce.create([this, e2], this._def);
  }
  and(e2) {
    return Ee.create(this, e2, this._def);
  }
  transform(e2) {
    return new Fe({ ...S(this._def), schema: this, typeName: Ye.ZodEffects, effect: { type: "transform", transform: e2 } });
  }
  default(e2) {
    const t = "function" == typeof e2 ? e2 : () => e2;
    return new Ne({ ...S(this._def), innerType: this, defaultValue: t, typeName: Ye.ZodDefault });
  }
  brand() {
    return new Oe({ typeName: Ye.ZodBranded, type: this, ...S(this._def) });
  }
  catch(e2) {
    const t = "function" == typeof e2 ? e2 : () => e2;
    return new Re({ ...S(this._def), innerType: this, catchValue: t, typeName: Ye.ZodCatch });
  }
  describe(e2) {
    return new (0, this.constructor)({ ...this._def, description: e2 });
  }
  pipe(e2) {
    return qe.create(this, e2);
  }
  readonly() {
    return je.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var G = /^c[^\s-]{8,}$/i;
var T = /^[0-9a-z]+$/;
var N = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var R = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var M = /^[a-z0-9_-]{21}$/i;
var U = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var O = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var q = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var j;
var J = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var Z = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var Y = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var H = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var K = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var P = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var z = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var V = new RegExp(`^${z}$`);
function W(e2) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e2.precision ? t = `${t}\\.\\d{${e2.precision}}` : null == e2.precision && (t = `${t}(\\.\\d+)?`), t;
}
function X(e2) {
  let t = `${z}T${W(e2)}`;
  const A2 = [];
  return A2.push(e2.local ? "Z?" : "Z"), e2.offset && A2.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${A2.join("|")})`, new RegExp(`^${t}$`);
}
function $(e2, t) {
  if (!U.test(e2)) return false;
  try {
    const [A2] = e2.split("."), i2 = A2.replace(/-/g, "+").replace(/_/g, "/").padEnd(A2.length + (4 - A2.length % 4) % 4, "="), a2 = JSON.parse(atob(i2));
    return "object" == typeof a2 && null !== a2 && (!(!a2.typ || !a2.alg) && (!t || a2.alg === t));
  } catch (e3) {
    return false;
  }
}
function ee(e2, t) {
  return !("v4" !== t && t || !Z.test(e2)) || !("v6" !== t && t || !H.test(e2));
}
var te = class _te extends F {
  _parse(e2) {
    this._def.coerce && (e2.data = String(e2.data));
    if (this._getType(e2) !== o.string) {
      const t2 = this._getOrReturnCtx(e2);
      return B(t2, { code: g.invalid_type, expected: o.string, received: t2.parsedType }), p;
    }
    const t = new C();
    let A2;
    for (const r2 of this._def.checks) if ("min" === r2.kind) e2.data.length < r2.value && (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.too_small, minimum: r2.value, type: "string", inclusive: true, exact: false, message: r2.message }), t.dirty());
    else if ("max" === r2.kind) e2.data.length > r2.value && (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.too_big, maximum: r2.value, type: "string", inclusive: true, exact: false, message: r2.message }), t.dirty());
    else if ("length" === r2.kind) {
      const i3 = e2.data.length > r2.value, a3 = e2.data.length < r2.value;
      (i3 || a3) && (A2 = this._getOrReturnCtx(e2, A2), i3 ? B(A2, { code: g.too_big, maximum: r2.value, type: "string", inclusive: true, exact: true, message: r2.message }) : a3 && B(A2, { code: g.too_small, minimum: r2.value, type: "string", inclusive: true, exact: true, message: r2.message }), t.dirty());
    } else if ("email" === r2.kind) q.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "email", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("emoji" === r2.kind) j || (j = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), j.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "emoji", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("uuid" === r2.kind) R.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "uuid", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("nanoid" === r2.kind) M.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "nanoid", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("cuid" === r2.kind) G.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "cuid", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("cuid2" === r2.kind) T.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "cuid2", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("ulid" === r2.kind) N.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "ulid", code: g.invalid_string, message: r2.message }), t.dirty());
    else if ("url" === r2.kind) try {
      new URL(e2.data);
    } catch (i3) {
      A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "url", code: g.invalid_string, message: r2.message }), t.dirty();
    }
    else if ("regex" === r2.kind) {
      r2.regex.lastIndex = 0;
      r2.regex.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "regex", code: g.invalid_string, message: r2.message }), t.dirty());
    } else if ("trim" === r2.kind) e2.data = e2.data.trim();
    else if ("includes" === r2.kind) e2.data.includes(r2.value, r2.position) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: { includes: r2.value, position: r2.position }, message: r2.message }), t.dirty());
    else if ("toLowerCase" === r2.kind) e2.data = e2.data.toLowerCase();
    else if ("toUpperCase" === r2.kind) e2.data = e2.data.toUpperCase();
    else if ("startsWith" === r2.kind) e2.data.startsWith(r2.value) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: { startsWith: r2.value }, message: r2.message }), t.dirty());
    else if ("endsWith" === r2.kind) e2.data.endsWith(r2.value) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: { endsWith: r2.value }, message: r2.message }), t.dirty());
    else if ("datetime" === r2.kind) {
      X(r2).test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: "datetime", message: r2.message }), t.dirty());
    } else if ("date" === r2.kind) {
      V.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: "date", message: r2.message }), t.dirty());
    } else if ("time" === r2.kind) {
      new RegExp(`^${W(r2)}$`).test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.invalid_string, validation: "time", message: r2.message }), t.dirty());
    } else "duration" === r2.kind ? O.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "duration", code: g.invalid_string, message: r2.message }), t.dirty()) : "ip" === r2.kind ? (i2 = e2.data, ("v4" !== (a2 = r2.version) && a2 || !J.test(i2)) && ("v6" !== a2 && a2 || !Y.test(i2)) && (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "ip", code: g.invalid_string, message: r2.message }), t.dirty())) : "jwt" === r2.kind ? $(e2.data, r2.alg) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "jwt", code: g.invalid_string, message: r2.message }), t.dirty()) : "cidr" === r2.kind ? ee(e2.data, r2.version) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "cidr", code: g.invalid_string, message: r2.message }), t.dirty()) : "base64" === r2.kind ? K.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "base64", code: g.invalid_string, message: r2.message }), t.dirty()) : "base64url" === r2.kind ? P.test(e2.data) || (A2 = this._getOrReturnCtx(e2, A2), B(A2, { validation: "base64url", code: g.invalid_string, message: r2.message }), t.dirty()) : s.assertNever(r2);
    var i2, a2;
    return { status: t.value, value: e2.data };
  }
  _regex(e2, t, A2) {
    return this.refinement((t2) => e2.test(t2), { validation: t, code: g.invalid_string, ...b.errToObj(A2) });
  }
  _addCheck(e2) {
    return new _te({ ...this._def, checks: [...this._def.checks, e2] });
  }
  email(e2) {
    return this._addCheck({ kind: "email", ...b.errToObj(e2) });
  }
  url(e2) {
    return this._addCheck({ kind: "url", ...b.errToObj(e2) });
  }
  emoji(e2) {
    return this._addCheck({ kind: "emoji", ...b.errToObj(e2) });
  }
  uuid(e2) {
    return this._addCheck({ kind: "uuid", ...b.errToObj(e2) });
  }
  nanoid(e2) {
    return this._addCheck({ kind: "nanoid", ...b.errToObj(e2) });
  }
  cuid(e2) {
    return this._addCheck({ kind: "cuid", ...b.errToObj(e2) });
  }
  cuid2(e2) {
    return this._addCheck({ kind: "cuid2", ...b.errToObj(e2) });
  }
  ulid(e2) {
    return this._addCheck({ kind: "ulid", ...b.errToObj(e2) });
  }
  base64(e2) {
    return this._addCheck({ kind: "base64", ...b.errToObj(e2) });
  }
  base64url(e2) {
    return this._addCheck({ kind: "base64url", ...b.errToObj(e2) });
  }
  jwt(e2) {
    return this._addCheck({ kind: "jwt", ...b.errToObj(e2) });
  }
  ip(e2) {
    return this._addCheck({ kind: "ip", ...b.errToObj(e2) });
  }
  cidr(e2) {
    return this._addCheck({ kind: "cidr", ...b.errToObj(e2) });
  }
  datetime(e2) {
    var t, A2;
    return "string" == typeof e2 ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e2 }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e2 ? void 0 : e2.precision) ? null : null == e2 ? void 0 : e2.precision, offset: null !== (t = null == e2 ? void 0 : e2.offset) && void 0 !== t && t, local: null !== (A2 = null == e2 ? void 0 : e2.local) && void 0 !== A2 && A2, ...b.errToObj(null == e2 ? void 0 : e2.message) });
  }
  date(e2) {
    return this._addCheck({ kind: "date", message: e2 });
  }
  time(e2) {
    return "string" == typeof e2 ? this._addCheck({ kind: "time", precision: null, message: e2 }) : this._addCheck({ kind: "time", precision: void 0 === (null == e2 ? void 0 : e2.precision) ? null : null == e2 ? void 0 : e2.precision, ...b.errToObj(null == e2 ? void 0 : e2.message) });
  }
  duration(e2) {
    return this._addCheck({ kind: "duration", ...b.errToObj(e2) });
  }
  regex(e2, t) {
    return this._addCheck({ kind: "regex", regex: e2, ...b.errToObj(t) });
  }
  includes(e2, t) {
    return this._addCheck({ kind: "includes", value: e2, position: null == t ? void 0 : t.position, ...b.errToObj(null == t ? void 0 : t.message) });
  }
  startsWith(e2, t) {
    return this._addCheck({ kind: "startsWith", value: e2, ...b.errToObj(t) });
  }
  endsWith(e2, t) {
    return this._addCheck({ kind: "endsWith", value: e2, ...b.errToObj(t) });
  }
  min(e2, t) {
    return this._addCheck({ kind: "min", value: e2, ...b.errToObj(t) });
  }
  max(e2, t) {
    return this._addCheck({ kind: "max", value: e2, ...b.errToObj(t) });
  }
  length(e2, t) {
    return this._addCheck({ kind: "length", value: e2, ...b.errToObj(t) });
  }
  nonempty(e2) {
    return this.min(1, b.errToObj(e2));
  }
  trim() {
    return new _te({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _te({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _te({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((e2) => "datetime" === e2.kind);
  }
  get isDate() {
    return !!this._def.checks.find((e2) => "date" === e2.kind);
  }
  get isTime() {
    return !!this._def.checks.find((e2) => "time" === e2.kind);
  }
  get isDuration() {
    return !!this._def.checks.find((e2) => "duration" === e2.kind);
  }
  get isEmail() {
    return !!this._def.checks.find((e2) => "email" === e2.kind);
  }
  get isURL() {
    return !!this._def.checks.find((e2) => "url" === e2.kind);
  }
  get isEmoji() {
    return !!this._def.checks.find((e2) => "emoji" === e2.kind);
  }
  get isUUID() {
    return !!this._def.checks.find((e2) => "uuid" === e2.kind);
  }
  get isNANOID() {
    return !!this._def.checks.find((e2) => "nanoid" === e2.kind);
  }
  get isCUID() {
    return !!this._def.checks.find((e2) => "cuid" === e2.kind);
  }
  get isCUID2() {
    return !!this._def.checks.find((e2) => "cuid2" === e2.kind);
  }
  get isULID() {
    return !!this._def.checks.find((e2) => "ulid" === e2.kind);
  }
  get isIP() {
    return !!this._def.checks.find((e2) => "ip" === e2.kind);
  }
  get isCIDR() {
    return !!this._def.checks.find((e2) => "cidr" === e2.kind);
  }
  get isBase64() {
    return !!this._def.checks.find((e2) => "base64" === e2.kind);
  }
  get isBase64url() {
    return !!this._def.checks.find((e2) => "base64url" === e2.kind);
  }
  get minLength() {
    let e2 = null;
    for (const t of this._def.checks) "min" === t.kind && (null === e2 || t.value > e2) && (e2 = t.value);
    return e2;
  }
  get maxLength() {
    let e2 = null;
    for (const t of this._def.checks) "max" === t.kind && (null === e2 || t.value < e2) && (e2 = t.value);
    return e2;
  }
};
function Ae(e2, t) {
  const A2 = (e2.toString().split(".")[1] || "").length, i2 = (t.toString().split(".")[1] || "").length, a2 = A2 > i2 ? A2 : i2;
  return parseInt(e2.toFixed(a2).replace(".", "")) % parseInt(t.toFixed(a2).replace(".", "")) / Math.pow(10, a2);
}
te.create = (e2) => {
  var t;
  return new te({ checks: [], typeName: Ye.ZodString, coerce: null !== (t = null == e2 ? void 0 : e2.coerce) && void 0 !== t && t, ...S(e2) });
};
var ie = class _ie extends F {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e2) {
    this._def.coerce && (e2.data = Number(e2.data));
    if (this._getType(e2) !== o.number) {
      const t2 = this._getOrReturnCtx(e2);
      return B(t2, { code: g.invalid_type, expected: o.number, received: t2.parsedType }), p;
    }
    let t;
    const A2 = new C();
    for (const i2 of this._def.checks) if ("int" === i2.kind) s.isInteger(e2.data) || (t = this._getOrReturnCtx(e2, t), B(t, { code: g.invalid_type, expected: "integer", received: "float", message: i2.message }), A2.dirty());
    else if ("min" === i2.kind) {
      (i2.inclusive ? e2.data < i2.value : e2.data <= i2.value) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.too_small, minimum: i2.value, type: "number", inclusive: i2.inclusive, exact: false, message: i2.message }), A2.dirty());
    } else if ("max" === i2.kind) {
      (i2.inclusive ? e2.data > i2.value : e2.data >= i2.value) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.too_big, maximum: i2.value, type: "number", inclusive: i2.inclusive, exact: false, message: i2.message }), A2.dirty());
    } else "multipleOf" === i2.kind ? 0 !== Ae(e2.data, i2.value) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.not_multiple_of, multipleOf: i2.value, message: i2.message }), A2.dirty()) : "finite" === i2.kind ? Number.isFinite(e2.data) || (t = this._getOrReturnCtx(e2, t), B(t, { code: g.not_finite, message: i2.message }), A2.dirty()) : s.assertNever(i2);
    return { status: A2.value, value: e2.data };
  }
  gte(e2, t) {
    return this.setLimit("min", e2, true, b.toString(t));
  }
  gt(e2, t) {
    return this.setLimit("min", e2, false, b.toString(t));
  }
  lte(e2, t) {
    return this.setLimit("max", e2, true, b.toString(t));
  }
  lt(e2, t) {
    return this.setLimit("max", e2, false, b.toString(t));
  }
  setLimit(e2, t, A2, i2) {
    return new _ie({ ...this._def, checks: [...this._def.checks, { kind: e2, value: t, inclusive: A2, message: b.toString(i2) }] });
  }
  _addCheck(e2) {
    return new _ie({ ...this._def, checks: [...this._def.checks, e2] });
  }
  int(e2) {
    return this._addCheck({ kind: "int", message: b.toString(e2) });
  }
  positive(e2) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: b.toString(e2) });
  }
  negative(e2) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: b.toString(e2) });
  }
  nonpositive(e2) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: b.toString(e2) });
  }
  nonnegative(e2) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: b.toString(e2) });
  }
  multipleOf(e2, t) {
    return this._addCheck({ kind: "multipleOf", value: e2, message: b.toString(t) });
  }
  finite(e2) {
    return this._addCheck({ kind: "finite", message: b.toString(e2) });
  }
  safe(e2) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: b.toString(e2) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: b.toString(e2) });
  }
  get minValue() {
    let e2 = null;
    for (const t of this._def.checks) "min" === t.kind && (null === e2 || t.value > e2) && (e2 = t.value);
    return e2;
  }
  get maxValue() {
    let e2 = null;
    for (const t of this._def.checks) "max" === t.kind && (null === e2 || t.value < e2) && (e2 = t.value);
    return e2;
  }
  get isInt() {
    return !!this._def.checks.find((e2) => "int" === e2.kind || "multipleOf" === e2.kind && s.isInteger(e2.value));
  }
  get isFinite() {
    let e2 = null, t = null;
    for (const A2 of this._def.checks) {
      if ("finite" === A2.kind || "int" === A2.kind || "multipleOf" === A2.kind) return true;
      "min" === A2.kind ? (null === t || A2.value > t) && (t = A2.value) : "max" === A2.kind && (null === e2 || A2.value < e2) && (e2 = A2.value);
    }
    return Number.isFinite(t) && Number.isFinite(e2);
  }
};
ie.create = (e2) => new ie({ checks: [], typeName: Ye.ZodNumber, coerce: (null == e2 ? void 0 : e2.coerce) || false, ...S(e2) });
var ae = class _ae extends F {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e2) {
    if (this._def.coerce) try {
      e2.data = BigInt(e2.data);
    } catch (t2) {
      return this._getInvalidInput(e2);
    }
    if (this._getType(e2) !== o.bigint) return this._getInvalidInput(e2);
    let t;
    const A2 = new C();
    for (const i2 of this._def.checks) if ("min" === i2.kind) {
      (i2.inclusive ? e2.data < i2.value : e2.data <= i2.value) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.too_small, type: "bigint", minimum: i2.value, inclusive: i2.inclusive, message: i2.message }), A2.dirty());
    } else if ("max" === i2.kind) {
      (i2.inclusive ? e2.data > i2.value : e2.data >= i2.value) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.too_big, type: "bigint", maximum: i2.value, inclusive: i2.inclusive, message: i2.message }), A2.dirty());
    } else "multipleOf" === i2.kind ? e2.data % i2.value !== BigInt(0) && (t = this._getOrReturnCtx(e2, t), B(t, { code: g.not_multiple_of, multipleOf: i2.value, message: i2.message }), A2.dirty()) : s.assertNever(i2);
    return { status: A2.value, value: e2.data };
  }
  _getInvalidInput(e2) {
    const t = this._getOrReturnCtx(e2);
    return B(t, { code: g.invalid_type, expected: o.bigint, received: t.parsedType }), p;
  }
  gte(e2, t) {
    return this.setLimit("min", e2, true, b.toString(t));
  }
  gt(e2, t) {
    return this.setLimit("min", e2, false, b.toString(t));
  }
  lte(e2, t) {
    return this.setLimit("max", e2, true, b.toString(t));
  }
  lt(e2, t) {
    return this.setLimit("max", e2, false, b.toString(t));
  }
  setLimit(e2, t, A2, i2) {
    return new _ae({ ...this._def, checks: [...this._def.checks, { kind: e2, value: t, inclusive: A2, message: b.toString(i2) }] });
  }
  _addCheck(e2) {
    return new _ae({ ...this._def, checks: [...this._def.checks, e2] });
  }
  positive(e2) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: b.toString(e2) });
  }
  negative(e2) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: b.toString(e2) });
  }
  nonpositive(e2) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: b.toString(e2) });
  }
  nonnegative(e2) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: b.toString(e2) });
  }
  multipleOf(e2, t) {
    return this._addCheck({ kind: "multipleOf", value: e2, message: b.toString(t) });
  }
  get minValue() {
    let e2 = null;
    for (const t of this._def.checks) "min" === t.kind && (null === e2 || t.value > e2) && (e2 = t.value);
    return e2;
  }
  get maxValue() {
    let e2 = null;
    for (const t of this._def.checks) "max" === t.kind && (null === e2 || t.value < e2) && (e2 = t.value);
    return e2;
  }
};
ae.create = (e2) => {
  var t;
  return new ae({ checks: [], typeName: Ye.ZodBigInt, coerce: null !== (t = null == e2 ? void 0 : e2.coerce) && void 0 !== t && t, ...S(e2) });
};
var se = class extends F {
  _parse(e2) {
    this._def.coerce && (e2.data = Boolean(e2.data));
    if (this._getType(e2) !== o.boolean) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.boolean, received: t.parsedType }), p;
    }
    return Q(e2.data);
  }
};
se.create = (e2) => new se({ typeName: Ye.ZodBoolean, coerce: (null == e2 ? void 0 : e2.coerce) || false, ...S(e2) });
var re = class _re extends F {
  _parse(e2) {
    this._def.coerce && (e2.data = new Date(e2.data));
    if (this._getType(e2) !== o.date) {
      const t2 = this._getOrReturnCtx(e2);
      return B(t2, { code: g.invalid_type, expected: o.date, received: t2.parsedType }), p;
    }
    if (isNaN(e2.data.getTime())) {
      return B(this._getOrReturnCtx(e2), { code: g.invalid_date }), p;
    }
    const t = new C();
    let A2;
    for (const i2 of this._def.checks) "min" === i2.kind ? e2.data.getTime() < i2.value && (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.too_small, message: i2.message, inclusive: true, exact: false, minimum: i2.value, type: "date" }), t.dirty()) : "max" === i2.kind ? e2.data.getTime() > i2.value && (A2 = this._getOrReturnCtx(e2, A2), B(A2, { code: g.too_big, message: i2.message, inclusive: true, exact: false, maximum: i2.value, type: "date" }), t.dirty()) : s.assertNever(i2);
    return { status: t.value, value: new Date(e2.data.getTime()) };
  }
  _addCheck(e2) {
    return new _re({ ...this._def, checks: [...this._def.checks, e2] });
  }
  min(e2, t) {
    return this._addCheck({ kind: "min", value: e2.getTime(), message: b.toString(t) });
  }
  max(e2, t) {
    return this._addCheck({ kind: "max", value: e2.getTime(), message: b.toString(t) });
  }
  get minDate() {
    let e2 = null;
    for (const t of this._def.checks) "min" === t.kind && (null === e2 || t.value > e2) && (e2 = t.value);
    return null != e2 ? new Date(e2) : null;
  }
  get maxDate() {
    let e2 = null;
    for (const t of this._def.checks) "max" === t.kind && (null === e2 || t.value < e2) && (e2 = t.value);
    return null != e2 ? new Date(e2) : null;
  }
};
re.create = (e2) => new re({ checks: [], coerce: (null == e2 ? void 0 : e2.coerce) || false, typeName: Ye.ZodDate, ...S(e2) });
var ne = class extends F {
  _parse(e2) {
    if (this._getType(e2) !== o.symbol) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.symbol, received: t.parsedType }), p;
    }
    return Q(e2.data);
  }
};
ne.create = (e2) => new ne({ typeName: Ye.ZodSymbol, ...S(e2) });
var oe = class extends F {
  _parse(e2) {
    if (this._getType(e2) !== o.undefined) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.undefined, received: t.parsedType }), p;
    }
    return Q(e2.data);
  }
};
oe.create = (e2) => new oe({ typeName: Ye.ZodUndefined, ...S(e2) });
var le = class extends F {
  _parse(e2) {
    if (this._getType(e2) !== o.null) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.null, received: t.parsedType }), p;
    }
    return Q(e2.data);
  }
};
le.create = (e2) => new le({ typeName: Ye.ZodNull, ...S(e2) });
var ge = class extends F {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e2) {
    return Q(e2.data);
  }
};
ge.create = (e2) => new ge({ typeName: Ye.ZodAny, ...S(e2) });
var de = class extends F {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e2) {
    return Q(e2.data);
  }
};
de.create = (e2) => new de({ typeName: Ye.ZodUnknown, ...S(e2) });
var he = class extends F {
  _parse(e2) {
    const t = this._getOrReturnCtx(e2);
    return B(t, { code: g.invalid_type, expected: o.never, received: t.parsedType }), p;
  }
};
he.create = (e2) => new he({ typeName: Ye.ZodNever, ...S(e2) });
var ce = class extends F {
  _parse(e2) {
    if (this._getType(e2) !== o.undefined) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.void, received: t.parsedType }), p;
    }
    return Q(e2.data);
  }
};
ce.create = (e2) => new ce({ typeName: Ye.ZodVoid, ...S(e2) });
var Ie = class _Ie extends F {
  _parse(e2) {
    const { ctx: t, status: A2 } = this._processInputParams(e2), i2 = this._def;
    if (t.parsedType !== o.array) return B(t, { code: g.invalid_type, expected: o.array, received: t.parsedType }), p;
    if (null !== i2.exactLength) {
      const e3 = t.data.length > i2.exactLength.value, a3 = t.data.length < i2.exactLength.value;
      (e3 || a3) && (B(t, { code: e3 ? g.too_big : g.too_small, minimum: a3 ? i2.exactLength.value : void 0, maximum: e3 ? i2.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: i2.exactLength.message }), A2.dirty());
    }
    if (null !== i2.minLength && t.data.length < i2.minLength.value && (B(t, { code: g.too_small, minimum: i2.minLength.value, type: "array", inclusive: true, exact: false, message: i2.minLength.message }), A2.dirty()), null !== i2.maxLength && t.data.length > i2.maxLength.value && (B(t, { code: g.too_big, maximum: i2.maxLength.value, type: "array", inclusive: true, exact: false, message: i2.maxLength.message }), A2.dirty()), t.common.async) return Promise.all([...t.data].map((e3, A3) => i2.type._parseAsync(new x(t, e3, t.path, A3)))).then((e3) => C.mergeArray(A2, e3));
    const a2 = [...t.data].map((e3, A3) => i2.type._parseSync(new x(t, e3, t.path, A3)));
    return C.mergeArray(A2, a2);
  }
  get element() {
    return this._def.type;
  }
  min(e2, t) {
    return new _Ie({ ...this._def, minLength: { value: e2, message: b.toString(t) } });
  }
  max(e2, t) {
    return new _Ie({ ...this._def, maxLength: { value: e2, message: b.toString(t) } });
  }
  length(e2, t) {
    return new _Ie({ ...this._def, exactLength: { value: e2, message: b.toString(t) } });
  }
  nonempty(e2) {
    return this.min(1, e2);
  }
};
function ue(e2) {
  if (e2 instanceof Be) {
    const t = {};
    for (const A2 in e2.shape) {
      const i2 = e2.shape[A2];
      t[A2] = Ge.create(ue(i2));
    }
    return new Be({ ...e2._def, shape: () => t });
  }
  return e2 instanceof Ie ? new Ie({ ...e2._def, type: ue(e2.element) }) : e2 instanceof Ge ? Ge.create(ue(e2.unwrap())) : e2 instanceof Te ? Te.create(ue(e2.unwrap())) : e2 instanceof me ? me.create(e2.items.map((e3) => ue(e3))) : e2;
}
Ie.create = (e2, t) => new Ie({ type: e2, minLength: null, maxLength: null, exactLength: null, typeName: Ye.ZodArray, ...S(t) });
var Be = class _Be extends F {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (null !== this._cached) return this._cached;
    const e2 = this._def.shape(), t = s.objectKeys(e2);
    return this._cached = { shape: e2, keys: t };
  }
  _parse(e2) {
    if (this._getType(e2) !== o.object) {
      const t2 = this._getOrReturnCtx(e2);
      return B(t2, { code: g.invalid_type, expected: o.object, received: t2.parsedType }), p;
    }
    const { status: t, ctx: A2 } = this._processInputParams(e2), { shape: i2, keys: a2 } = this._getCached(), s2 = [];
    if (!(this._def.catchall instanceof he && "strip" === this._def.unknownKeys)) for (const e3 in A2.data) a2.includes(e3) || s2.push(e3);
    const r2 = [];
    for (const e3 of a2) {
      const t2 = i2[e3], a3 = A2.data[e3];
      r2.push({ key: { status: "valid", value: e3 }, value: t2._parse(new x(A2, a3, A2.path, e3)), alwaysSet: e3 in A2.data });
    }
    if (this._def.catchall instanceof he) {
      const e3 = this._def.unknownKeys;
      if ("passthrough" === e3) for (const e4 of s2) r2.push({ key: { status: "valid", value: e4 }, value: { status: "valid", value: A2.data[e4] } });
      else if ("strict" === e3) s2.length > 0 && (B(A2, { code: g.unrecognized_keys, keys: s2 }), t.dirty());
      else if ("strip" !== e3) throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const e3 = this._def.catchall;
      for (const t2 of s2) {
        const i3 = A2.data[t2];
        r2.push({ key: { status: "valid", value: t2 }, value: e3._parse(new x(A2, i3, A2.path, t2)), alwaysSet: t2 in A2.data });
      }
    }
    return A2.common.async ? Promise.resolve().then(async () => {
      const e3 = [];
      for (const t2 of r2) {
        const A3 = await t2.key, i3 = await t2.value;
        e3.push({ key: A3, value: i3, alwaysSet: t2.alwaysSet });
      }
      return e3;
    }).then((e3) => C.mergeObjectSync(t, e3)) : C.mergeObjectSync(t, r2);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e2) {
    return b.errToObj, new _Be({ ...this._def, unknownKeys: "strict", ...void 0 !== e2 ? { errorMap: (t, A2) => {
      var i2, a2, s2, r2;
      const n2 = null !== (s2 = null === (a2 = (i2 = this._def).errorMap) || void 0 === a2 ? void 0 : a2.call(i2, t, A2).message) && void 0 !== s2 ? s2 : A2.defaultError;
      return "unrecognized_keys" === t.code ? { message: null !== (r2 = b.errToObj(e2).message) && void 0 !== r2 ? r2 : n2 } : { message: n2 };
    } } : {} });
  }
  strip() {
    return new _Be({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _Be({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e2) {
    return new _Be({ ...this._def, shape: () => ({ ...this._def.shape(), ...e2 }) });
  }
  merge(e2) {
    return new _Be({ unknownKeys: e2._def.unknownKeys, catchall: e2._def.catchall, shape: () => ({ ...this._def.shape(), ...e2._def.shape() }), typeName: Ye.ZodObject });
  }
  setKey(e2, t) {
    return this.augment({ [e2]: t });
  }
  catchall(e2) {
    return new _Be({ ...this._def, catchall: e2 });
  }
  pick(e2) {
    const t = {};
    return s.objectKeys(e2).forEach((A2) => {
      e2[A2] && this.shape[A2] && (t[A2] = this.shape[A2]);
    }), new _Be({ ...this._def, shape: () => t });
  }
  omit(e2) {
    const t = {};
    return s.objectKeys(this.shape).forEach((A2) => {
      e2[A2] || (t[A2] = this.shape[A2]);
    }), new _Be({ ...this._def, shape: () => t });
  }
  deepPartial() {
    return ue(this);
  }
  partial(e2) {
    const t = {};
    return s.objectKeys(this.shape).forEach((A2) => {
      const i2 = this.shape[A2];
      e2 && !e2[A2] ? t[A2] = i2 : t[A2] = i2.optional();
    }), new _Be({ ...this._def, shape: () => t });
  }
  required(e2) {
    const t = {};
    return s.objectKeys(this.shape).forEach((A2) => {
      if (e2 && !e2[A2]) t[A2] = this.shape[A2];
      else {
        let e3 = this.shape[A2];
        for (; e3 instanceof Ge; ) e3 = e3._def.innerType;
        t[A2] = e3;
      }
    }), new _Be({ ...this._def, shape: () => t });
  }
  keyof() {
    return De(s.objectKeys(this.shape));
  }
};
Be.create = (e2, t) => new Be({ shape: () => e2, unknownKeys: "strip", catchall: he.create(), typeName: Ye.ZodObject, ...S(t) }), Be.strictCreate = (e2, t) => new Be({ shape: () => e2, unknownKeys: "strict", catchall: he.create(), typeName: Ye.ZodObject, ...S(t) }), Be.lazycreate = (e2, t) => new Be({ shape: e2, unknownKeys: "strip", catchall: he.create(), typeName: Ye.ZodObject, ...S(t) });
var Ce = class extends F {
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2), A2 = this._def.options;
    if (t.common.async) return Promise.all(A2.map(async (e3) => {
      const A3 = { ...t, common: { ...t.common, issues: [] }, parent: null };
      return { result: await e3._parseAsync({ data: t.data, path: t.path, parent: A3 }), ctx: A3 };
    })).then(function(e3) {
      for (const t2 of e3) if ("valid" === t2.result.status) return t2.result;
      for (const A4 of e3) if ("dirty" === A4.result.status) return t.common.issues.push(...A4.ctx.common.issues), A4.result;
      const A3 = e3.map((e4) => new d(e4.ctx.common.issues));
      return B(t, { code: g.invalid_union, unionErrors: A3 }), p;
    });
    {
      let e3;
      const i2 = [];
      for (const a3 of A2) {
        const A3 = { ...t, common: { ...t.common, issues: [] }, parent: null }, s2 = a3._parseSync({ data: t.data, path: t.path, parent: A3 });
        if ("valid" === s2.status) return s2;
        "dirty" !== s2.status || e3 || (e3 = { result: s2, ctx: A3 }), A3.common.issues.length && i2.push(A3.common.issues);
      }
      if (e3) return t.common.issues.push(...e3.ctx.common.issues), e3.result;
      const a2 = i2.map((e4) => new d(e4));
      return B(t, { code: g.invalid_union, unionErrors: a2 }), p;
    }
  }
  get options() {
    return this._def.options;
  }
};
Ce.create = (e2, t) => new Ce({ options: e2, typeName: Ye.ZodUnion, ...S(t) });
var pe = (e2) => e2 instanceof be ? pe(e2.schema) : e2 instanceof Fe ? pe(e2.innerType()) : e2 instanceof ke ? [e2.value] : e2 instanceof xe ? e2.options : e2 instanceof Le ? s.objectValues(e2.enum) : e2 instanceof Ne ? pe(e2._def.innerType) : e2 instanceof oe ? [void 0] : e2 instanceof le ? [null] : e2 instanceof Ge ? [void 0, ...pe(e2.unwrap())] : e2 instanceof Te ? [null, ...pe(e2.unwrap())] : e2 instanceof Oe || e2 instanceof je ? pe(e2.unwrap()) : e2 instanceof Re ? pe(e2._def.innerType) : [];
var fe = class _fe extends F {
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2);
    if (t.parsedType !== o.object) return B(t, { code: g.invalid_type, expected: o.object, received: t.parsedType }), p;
    const A2 = this.discriminator, i2 = t.data[A2], a2 = this.optionsMap.get(i2);
    return a2 ? t.common.async ? a2._parseAsync({ data: t.data, path: t.path, parent: t }) : a2._parseSync({ data: t.data, path: t.path, parent: t }) : (B(t, { code: g.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [A2] }), p);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e2, t, A2) {
    const i2 = /* @__PURE__ */ new Map();
    for (const A3 of t) {
      const t2 = pe(A3.shape[e2]);
      if (!t2.length) throw new Error(`A discriminator value for key \`${e2}\` could not be extracted from all schema options`);
      for (const a2 of t2) {
        if (i2.has(a2)) throw new Error(`Discriminator property ${String(e2)} has duplicate value ${String(a2)}`);
        i2.set(a2, A3);
      }
    }
    return new _fe({ typeName: Ye.ZodDiscriminatedUnion, discriminator: e2, options: t, optionsMap: i2, ...S(A2) });
  }
};
function Qe(e2, t) {
  const A2 = l(e2), i2 = l(t);
  if (e2 === t) return { valid: true, data: e2 };
  if (A2 === o.object && i2 === o.object) {
    const A3 = s.objectKeys(t), i3 = s.objectKeys(e2).filter((e3) => -1 !== A3.indexOf(e3)), a2 = { ...e2, ...t };
    for (const A4 of i3) {
      const i4 = Qe(e2[A4], t[A4]);
      if (!i4.valid) return { valid: false };
      a2[A4] = i4.data;
    }
    return { valid: true, data: a2 };
  }
  if (A2 === o.array && i2 === o.array) {
    if (e2.length !== t.length) return { valid: false };
    const A3 = [];
    for (let i3 = 0; i3 < e2.length; i3++) {
      const a2 = Qe(e2[i3], t[i3]);
      if (!a2.valid) return { valid: false };
      A3.push(a2.data);
    }
    return { valid: true, data: A3 };
  }
  return A2 === o.date && i2 === o.date && +e2 == +t ? { valid: true, data: e2 } : { valid: false };
}
var Ee = class extends F {
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2), i2 = (e3, i3) => {
      if (E(e3) || E(i3)) return p;
      const a2 = Qe(e3.value, i3.value);
      return a2.valid ? ((m(e3) || m(i3)) && t.dirty(), { status: t.value, value: a2.data }) : (B(A2, { code: g.invalid_intersection_types }), p);
    };
    return A2.common.async ? Promise.all([this._def.left._parseAsync({ data: A2.data, path: A2.path, parent: A2 }), this._def.right._parseAsync({ data: A2.data, path: A2.path, parent: A2 })]).then(([e3, t2]) => i2(e3, t2)) : i2(this._def.left._parseSync({ data: A2.data, path: A2.path, parent: A2 }), this._def.right._parseSync({ data: A2.data, path: A2.path, parent: A2 }));
  }
};
Ee.create = (e2, t, A2) => new Ee({ left: e2, right: t, typeName: Ye.ZodIntersection, ...S(A2) });
var me = class _me extends F {
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2);
    if (A2.parsedType !== o.array) return B(A2, { code: g.invalid_type, expected: o.array, received: A2.parsedType }), p;
    if (A2.data.length < this._def.items.length) return B(A2, { code: g.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), p;
    !this._def.rest && A2.data.length > this._def.items.length && (B(A2, { code: g.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t.dirty());
    const i2 = [...A2.data].map((e3, t2) => {
      const i3 = this._def.items[t2] || this._def.rest;
      return i3 ? i3._parse(new x(A2, e3, A2.path, t2)) : null;
    }).filter((e3) => !!e3);
    return A2.common.async ? Promise.all(i2).then((e3) => C.mergeArray(t, e3)) : C.mergeArray(t, i2);
  }
  get items() {
    return this._def.items;
  }
  rest(e2) {
    return new _me({ ...this._def, rest: e2 });
  }
};
me.create = (e2, t) => {
  if (!Array.isArray(e2)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new me({ items: e2, typeName: Ye.ZodTuple, rest: null, ...S(t) });
};
var ye = class _ye extends F {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2);
    if (A2.parsedType !== o.object) return B(A2, { code: g.invalid_type, expected: o.object, received: A2.parsedType }), p;
    const i2 = [], a2 = this._def.keyType, s2 = this._def.valueType;
    for (const e3 in A2.data) i2.push({ key: a2._parse(new x(A2, e3, A2.path, e3)), value: s2._parse(new x(A2, A2.data[e3], A2.path, e3)), alwaysSet: e3 in A2.data });
    return A2.common.async ? C.mergeObjectAsync(t, i2) : C.mergeObjectSync(t, i2);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e2, t, A2) {
    return new _ye(t instanceof F ? { keyType: e2, valueType: t, typeName: Ye.ZodRecord, ...S(A2) } : { keyType: te.create(), valueType: e2, typeName: Ye.ZodRecord, ...S(t) });
  }
};
var we = class extends F {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2);
    if (A2.parsedType !== o.map) return B(A2, { code: g.invalid_type, expected: o.map, received: A2.parsedType }), p;
    const i2 = this._def.keyType, a2 = this._def.valueType, s2 = [...A2.data.entries()].map(([e3, t2], s3) => ({ key: i2._parse(new x(A2, e3, A2.path, [s3, "key"])), value: a2._parse(new x(A2, t2, A2.path, [s3, "value"])) }));
    if (A2.common.async) {
      const e3 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const A3 of s2) {
          const i3 = await A3.key, a3 = await A3.value;
          if ("aborted" === i3.status || "aborted" === a3.status) return p;
          "dirty" !== i3.status && "dirty" !== a3.status || t.dirty(), e3.set(i3.value, a3.value);
        }
        return { status: t.value, value: e3 };
      });
    }
    {
      const e3 = /* @__PURE__ */ new Map();
      for (const A3 of s2) {
        const i3 = A3.key, a3 = A3.value;
        if ("aborted" === i3.status || "aborted" === a3.status) return p;
        "dirty" !== i3.status && "dirty" !== a3.status || t.dirty(), e3.set(i3.value, a3.value);
      }
      return { status: t.value, value: e3 };
    }
  }
};
we.create = (e2, t, A2) => new we({ valueType: t, keyType: e2, typeName: Ye.ZodMap, ...S(A2) });
var _e = class __e extends F {
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2);
    if (A2.parsedType !== o.set) return B(A2, { code: g.invalid_type, expected: o.set, received: A2.parsedType }), p;
    const i2 = this._def;
    null !== i2.minSize && A2.data.size < i2.minSize.value && (B(A2, { code: g.too_small, minimum: i2.minSize.value, type: "set", inclusive: true, exact: false, message: i2.minSize.message }), t.dirty()), null !== i2.maxSize && A2.data.size > i2.maxSize.value && (B(A2, { code: g.too_big, maximum: i2.maxSize.value, type: "set", inclusive: true, exact: false, message: i2.maxSize.message }), t.dirty());
    const a2 = this._def.valueType;
    function s2(e3) {
      const A3 = /* @__PURE__ */ new Set();
      for (const i3 of e3) {
        if ("aborted" === i3.status) return p;
        "dirty" === i3.status && t.dirty(), A3.add(i3.value);
      }
      return { status: t.value, value: A3 };
    }
    const r2 = [...A2.data.values()].map((e3, t2) => a2._parse(new x(A2, e3, A2.path, t2)));
    return A2.common.async ? Promise.all(r2).then((e3) => s2(e3)) : s2(r2);
  }
  min(e2, t) {
    return new __e({ ...this._def, minSize: { value: e2, message: b.toString(t) } });
  }
  max(e2, t) {
    return new __e({ ...this._def, maxSize: { value: e2, message: b.toString(t) } });
  }
  size(e2, t) {
    return this.min(e2, t).max(e2, t);
  }
  nonempty(e2) {
    return this.min(1, e2);
  }
};
_e.create = (e2, t) => new _e({ valueType: e2, minSize: null, maxSize: null, typeName: Ye.ZodSet, ...S(t) });
var ve = class _ve extends F {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2);
    if (t.parsedType !== o.function) return B(t, { code: g.invalid_type, expected: o.function, received: t.parsedType }), p;
    function A2(e3, A3) {
      return u({ data: e3, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, I(), h].filter((e4) => !!e4), issueData: { code: g.invalid_arguments, argumentsError: A3 } });
    }
    function i2(e3, A3) {
      return u({ data: e3, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, I(), h].filter((e4) => !!e4), issueData: { code: g.invalid_return_type, returnTypeError: A3 } });
    }
    const a2 = { errorMap: t.common.contextualErrorMap }, s2 = t.data;
    if (this._def.returns instanceof Se) {
      const e3 = this;
      return Q(async function(...t2) {
        const r2 = new d([]), n2 = await e3._def.args.parseAsync(t2, a2).catch((e4) => {
          throw r2.addIssue(A2(t2, e4)), r2;
        }), o2 = await Reflect.apply(s2, this, n2);
        return await e3._def.returns._def.type.parseAsync(o2, a2).catch((e4) => {
          throw r2.addIssue(i2(o2, e4)), r2;
        });
      });
    }
    {
      const e3 = this;
      return Q(function(...t2) {
        const r2 = e3._def.args.safeParse(t2, a2);
        if (!r2.success) throw new d([A2(t2, r2.error)]);
        const n2 = Reflect.apply(s2, this, r2.data), o2 = e3._def.returns.safeParse(n2, a2);
        if (!o2.success) throw new d([i2(n2, o2.error)]);
        return o2.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e2) {
    return new _ve({ ...this._def, args: me.create(e2).rest(de.create()) });
  }
  returns(e2) {
    return new _ve({ ...this._def, returns: e2 });
  }
  implement(e2) {
    return this.parse(e2);
  }
  strictImplement(e2) {
    return this.parse(e2);
  }
  static create(e2, t, A2) {
    return new _ve({ args: e2 || me.create([]).rest(de.create()), returns: t || de.create(), typeName: Ye.ZodFunction, ...S(A2) });
  }
};
var be = class extends F {
  get schema() {
    return this._def.getter();
  }
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
};
be.create = (e2, t) => new be({ getter: e2, typeName: Ye.ZodLazy, ...S(t) });
var ke = class extends F {
  _parse(e2) {
    if (e2.data !== this._def.value) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { received: t.data, code: g.invalid_literal, expected: this._def.value }), p;
    }
    return { status: "valid", value: e2.data };
  }
  get value() {
    return this._def.value;
  }
};
function De(e2, t) {
  return new xe({ values: e2, typeName: Ye.ZodEnum, ...S(t) });
}
ke.create = (e2, t) => new ke({ value: e2, typeName: Ye.ZodLiteral, ...S(t) });
var xe = class _xe extends F {
  constructor() {
    super(...arguments), k.set(this, void 0);
  }
  _parse(e2) {
    if ("string" != typeof e2.data) {
      const t = this._getOrReturnCtx(e2), A2 = this._def.values;
      return B(t, { expected: s.joinValues(A2), received: t.parsedType, code: g.invalid_type }), p;
    }
    if (_(this, k, "f") || v(this, k, new Set(this._def.values), "f"), !_(this, k, "f").has(e2.data)) {
      const t = this._getOrReturnCtx(e2), A2 = this._def.values;
      return B(t, { received: t.data, code: g.invalid_enum_value, options: A2 }), p;
    }
    return Q(e2.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e2 = {};
    for (const t of this._def.values) e2[t] = t;
    return e2;
  }
  get Values() {
    const e2 = {};
    for (const t of this._def.values) e2[t] = t;
    return e2;
  }
  get Enum() {
    const e2 = {};
    for (const t of this._def.values) e2[t] = t;
    return e2;
  }
  extract(e2, t = this._def) {
    return _xe.create(e2, { ...this._def, ...t });
  }
  exclude(e2, t = this._def) {
    return _xe.create(this.options.filter((t2) => !e2.includes(t2)), { ...this._def, ...t });
  }
};
k = /* @__PURE__ */ new WeakMap(), xe.create = De;
var Le = class extends F {
  constructor() {
    super(...arguments), D.set(this, void 0);
  }
  _parse(e2) {
    const t = s.getValidEnumValues(this._def.values), A2 = this._getOrReturnCtx(e2);
    if (A2.parsedType !== o.string && A2.parsedType !== o.number) {
      const e3 = s.objectValues(t);
      return B(A2, { expected: s.joinValues(e3), received: A2.parsedType, code: g.invalid_type }), p;
    }
    if (_(this, D, "f") || v(this, D, new Set(s.getValidEnumValues(this._def.values)), "f"), !_(this, D, "f").has(e2.data)) {
      const e3 = s.objectValues(t);
      return B(A2, { received: A2.data, code: g.invalid_enum_value, options: e3 }), p;
    }
    return Q(e2.data);
  }
  get enum() {
    return this._def.values;
  }
};
D = /* @__PURE__ */ new WeakMap(), Le.create = (e2, t) => new Le({ values: e2, typeName: Ye.ZodNativeEnum, ...S(t) });
var Se = class extends F {
  unwrap() {
    return this._def.type;
  }
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2);
    if (t.parsedType !== o.promise && false === t.common.async) return B(t, { code: g.invalid_type, expected: o.promise, received: t.parsedType }), p;
    const A2 = t.parsedType === o.promise ? t.data : Promise.resolve(t.data);
    return Q(A2.then((e3) => this._def.type.parseAsync(e3, { path: t.path, errorMap: t.common.contextualErrorMap })));
  }
};
Se.create = (e2, t) => new Se({ type: e2, typeName: Ye.ZodPromise, ...S(t) });
var Fe = class extends F {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ye.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2), i2 = this._def.effect || null, a2 = { addIssue: (e3) => {
      B(A2, e3), e3.fatal ? t.abort() : t.dirty();
    }, get path() {
      return A2.path;
    } };
    if (a2.addIssue = a2.addIssue.bind(a2), "preprocess" === i2.type) {
      const e3 = i2.transform(A2.data, a2);
      if (A2.common.async) return Promise.resolve(e3).then(async (e4) => {
        if ("aborted" === t.value) return p;
        const i3 = await this._def.schema._parseAsync({ data: e4, path: A2.path, parent: A2 });
        return "aborted" === i3.status ? p : "dirty" === i3.status || "dirty" === t.value ? f(i3.value) : i3;
      });
      {
        if ("aborted" === t.value) return p;
        const i3 = this._def.schema._parseSync({ data: e3, path: A2.path, parent: A2 });
        return "aborted" === i3.status ? p : "dirty" === i3.status || "dirty" === t.value ? f(i3.value) : i3;
      }
    }
    if ("refinement" === i2.type) {
      const e3 = (e4) => {
        const t2 = i2.refinement(e4, a2);
        if (A2.common.async) return Promise.resolve(t2);
        if (t2 instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return e4;
      };
      if (false === A2.common.async) {
        const i3 = this._def.schema._parseSync({ data: A2.data, path: A2.path, parent: A2 });
        return "aborted" === i3.status ? p : ("dirty" === i3.status && t.dirty(), e3(i3.value), { status: t.value, value: i3.value });
      }
      return this._def.schema._parseAsync({ data: A2.data, path: A2.path, parent: A2 }).then((A3) => "aborted" === A3.status ? p : ("dirty" === A3.status && t.dirty(), e3(A3.value).then(() => ({ status: t.value, value: A3.value }))));
    }
    if ("transform" === i2.type) {
      if (false === A2.common.async) {
        const e3 = this._def.schema._parseSync({ data: A2.data, path: A2.path, parent: A2 });
        if (!y(e3)) return e3;
        const s2 = i2.transform(e3.value, a2);
        if (s2 instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: s2 };
      }
      return this._def.schema._parseAsync({ data: A2.data, path: A2.path, parent: A2 }).then((e3) => y(e3) ? Promise.resolve(i2.transform(e3.value, a2)).then((e4) => ({ status: t.value, value: e4 })) : e3);
    }
    s.assertNever(i2);
  }
};
Fe.create = (e2, t, A2) => new Fe({ schema: e2, typeName: Ye.ZodEffects, effect: t, ...S(A2) }), Fe.createWithPreprocess = (e2, t, A2) => new Fe({ schema: t, effect: { type: "preprocess", transform: e2 }, typeName: Ye.ZodEffects, ...S(A2) });
var Ge = class extends F {
  _parse(e2) {
    return this._getType(e2) === o.undefined ? Q(void 0) : this._def.innerType._parse(e2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ge.create = (e2, t) => new Ge({ innerType: e2, typeName: Ye.ZodOptional, ...S(t) });
var Te = class extends F {
  _parse(e2) {
    return this._getType(e2) === o.null ? Q(null) : this._def.innerType._parse(e2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Te.create = (e2, t) => new Te({ innerType: e2, typeName: Ye.ZodNullable, ...S(t) });
var Ne = class extends F {
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2);
    let A2 = t.data;
    return t.parsedType === o.undefined && (A2 = this._def.defaultValue()), this._def.innerType._parse({ data: A2, path: t.path, parent: t });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Ne.create = (e2, t) => new Ne({ innerType: e2, typeName: Ye.ZodDefault, defaultValue: "function" == typeof t.default ? t.default : () => t.default, ...S(t) });
var Re = class extends F {
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2), A2 = { ...t, common: { ...t.common, issues: [] } }, i2 = this._def.innerType._parse({ data: A2.data, path: A2.path, parent: { ...A2 } });
    return w(i2) ? i2.then((e3) => ({ status: "valid", value: "valid" === e3.status ? e3.value : this._def.catchValue({ get error() {
      return new d(A2.common.issues);
    }, input: A2.data }) })) : { status: "valid", value: "valid" === i2.status ? i2.value : this._def.catchValue({ get error() {
      return new d(A2.common.issues);
    }, input: A2.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Re.create = (e2, t) => new Re({ innerType: e2, typeName: Ye.ZodCatch, catchValue: "function" == typeof t.catch ? t.catch : () => t.catch, ...S(t) });
var Me = class extends F {
  _parse(e2) {
    if (this._getType(e2) !== o.nan) {
      const t = this._getOrReturnCtx(e2);
      return B(t, { code: g.invalid_type, expected: o.nan, received: t.parsedType }), p;
    }
    return { status: "valid", value: e2.data };
  }
};
Me.create = (e2) => new Me({ typeName: Ye.ZodNaN, ...S(e2) });
var Ue = Symbol("zod_brand");
var Oe = class extends F {
  _parse(e2) {
    const { ctx: t } = this._processInputParams(e2), A2 = t.data;
    return this._def.type._parse({ data: A2, path: t.path, parent: t });
  }
  unwrap() {
    return this._def.type;
  }
};
var qe = class _qe extends F {
  _parse(e2) {
    const { status: t, ctx: A2 } = this._processInputParams(e2);
    if (A2.common.async) {
      return (async () => {
        const e3 = await this._def.in._parseAsync({ data: A2.data, path: A2.path, parent: A2 });
        return "aborted" === e3.status ? p : "dirty" === e3.status ? (t.dirty(), f(e3.value)) : this._def.out._parseAsync({ data: e3.value, path: A2.path, parent: A2 });
      })();
    }
    {
      const e3 = this._def.in._parseSync({ data: A2.data, path: A2.path, parent: A2 });
      return "aborted" === e3.status ? p : "dirty" === e3.status ? (t.dirty(), { status: "dirty", value: e3.value }) : this._def.out._parseSync({ data: e3.value, path: A2.path, parent: A2 });
    }
  }
  static create(e2, t) {
    return new _qe({ in: e2, out: t, typeName: Ye.ZodPipeline });
  }
};
var je = class extends F {
  _parse(e2) {
    const t = this._def.innerType._parse(e2), A2 = (e3) => (y(e3) && (e3.value = Object.freeze(e3.value)), e3);
    return w(t) ? t.then((e3) => A2(e3)) : A2(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
function Je(e2, t = {}, A2) {
  return e2 ? ge.create().superRefine((i2, a2) => {
    var s2, r2;
    if (!e2(i2)) {
      const e3 = "function" == typeof t ? t(i2) : "string" == typeof t ? { message: t } : t, n2 = null === (r2 = null !== (s2 = e3.fatal) && void 0 !== s2 ? s2 : A2) || void 0 === r2 || r2, o2 = "string" == typeof e3 ? { message: e3 } : e3;
      a2.addIssue({ code: "custom", ...o2, fatal: n2 });
    }
  }) : ge.create();
}
je.create = (e2, t) => new je({ innerType: e2, typeName: Ye.ZodReadonly, ...S(t) });
var Ze = { object: Be.lazycreate };
var Ye;
!function(e2) {
  e2.ZodString = "ZodString", e2.ZodNumber = "ZodNumber", e2.ZodNaN = "ZodNaN", e2.ZodBigInt = "ZodBigInt", e2.ZodBoolean = "ZodBoolean", e2.ZodDate = "ZodDate", e2.ZodSymbol = "ZodSymbol", e2.ZodUndefined = "ZodUndefined", e2.ZodNull = "ZodNull", e2.ZodAny = "ZodAny", e2.ZodUnknown = "ZodUnknown", e2.ZodNever = "ZodNever", e2.ZodVoid = "ZodVoid", e2.ZodArray = "ZodArray", e2.ZodObject = "ZodObject", e2.ZodUnion = "ZodUnion", e2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e2.ZodIntersection = "ZodIntersection", e2.ZodTuple = "ZodTuple", e2.ZodRecord = "ZodRecord", e2.ZodMap = "ZodMap", e2.ZodSet = "ZodSet", e2.ZodFunction = "ZodFunction", e2.ZodLazy = "ZodLazy", e2.ZodLiteral = "ZodLiteral", e2.ZodEnum = "ZodEnum", e2.ZodEffects = "ZodEffects", e2.ZodNativeEnum = "ZodNativeEnum", e2.ZodOptional = "ZodOptional", e2.ZodNullable = "ZodNullable", e2.ZodDefault = "ZodDefault", e2.ZodCatch = "ZodCatch", e2.ZodPromise = "ZodPromise", e2.ZodBranded = "ZodBranded", e2.ZodPipeline = "ZodPipeline", e2.ZodReadonly = "ZodReadonly";
}(Ye || (Ye = {}));
var He = te.create;
var Ke = ie.create;
var Pe = Me.create;
var ze = ae.create;
var Ve = se.create;
var We = re.create;
var Xe = ne.create;
var $e = oe.create;
var et = le.create;
var tt = ge.create;
var At = de.create;
var it = he.create;
var at = ce.create;
var st = Ie.create;
var rt = Be.create;
var nt = Be.strictCreate;
var ot = Ce.create;
var lt = fe.create;
var gt = Ee.create;
var dt = me.create;
var ht = ye.create;
var ct = we.create;
var It = _e.create;
var ut = ve.create;
var Bt = be.create;
var Ct = ke.create;
var pt = xe.create;
var ft = Le.create;
var Qt = Se.create;
var Et = Fe.create;
var mt = Ge.create;
var yt = Te.create;
var wt = Fe.createWithPreprocess;
var _t = qe.create;
var vt = { string: (e2) => te.create({ ...e2, coerce: true }), number: (e2) => ie.create({ ...e2, coerce: true }), boolean: (e2) => se.create({ ...e2, coerce: true }), bigint: (e2) => ae.create({ ...e2, coerce: true }), date: (e2) => re.create({ ...e2, coerce: true }) };
var bt = p;
var kt = Object.freeze({ __proto__: null, defaultErrorMap: h, setErrorMap: function(e2) {
  c = e2;
}, getErrorMap: I, makeIssue: u, EMPTY_PATH: [], addIssueToContext: B, ParseStatus: C, INVALID: p, DIRTY: f, OK: Q, isAborted: E, isDirty: m, isValid: y, isAsync: w, get util() {
  return s;
}, get objectUtil() {
  return r;
}, ZodParsedType: o, getParsedType: l, ZodType: F, datetimeRegex: X, ZodString: te, ZodNumber: ie, ZodBigInt: ae, ZodBoolean: se, ZodDate: re, ZodSymbol: ne, ZodUndefined: oe, ZodNull: le, ZodAny: ge, ZodUnknown: de, ZodNever: he, ZodVoid: ce, ZodArray: Ie, ZodObject: Be, ZodUnion: Ce, ZodDiscriminatedUnion: fe, ZodIntersection: Ee, ZodTuple: me, ZodRecord: ye, ZodMap: we, ZodSet: _e, ZodFunction: ve, ZodLazy: be, ZodLiteral: ke, ZodEnum: xe, ZodNativeEnum: Le, ZodPromise: Se, ZodEffects: Fe, ZodTransformer: Fe, ZodOptional: Ge, ZodNullable: Te, ZodDefault: Ne, ZodCatch: Re, ZodNaN: Me, BRAND: Ue, ZodBranded: Oe, ZodPipeline: qe, ZodReadonly: je, custom: Je, Schema: F, ZodSchema: F, late: Ze, get ZodFirstPartyTypeKind() {
  return Ye;
}, coerce: vt, any: tt, array: st, bigint: ze, boolean: Ve, date: We, discriminatedUnion: lt, effect: Et, enum: pt, function: ut, instanceof: (e2, t = { message: `Input not instance of ${e2.name}` }) => Je((t2) => t2 instanceof e2, t), intersection: gt, lazy: Bt, literal: Ct, map: ct, nan: Pe, nativeEnum: ft, never: it, null: et, nullable: yt, number: Ke, object: rt, oboolean: () => Ve().optional(), onumber: () => Ke().optional(), optional: mt, ostring: () => He().optional(), pipeline: _t, preprocess: wt, promise: Qt, record: ht, set: It, strictObject: nt, string: He, symbol: Xe, transformer: Et, tuple: dt, undefined: $e, union: ot, unknown: At, void: at, NEVER: bt, ZodIssueCode: g, quotelessJson: (e2) => JSON.stringify(e2, null, 2).replace(/"([^"]+)":/g, "$1:"), ZodError: d });
var Dt = kt.object({ name: kt.string(), type: kt.literal("int"), value: kt.number().int() });
var xt = kt.object({ name: kt.string(), type: kt.literal("bool"), value: kt.boolean() });
var Lt = kt.object({ name: kt.string(), type: kt.literal("float"), value: kt.number() });
var St = kt.object({ name: kt.string(), type: kt.literal("string"), value: kt.string() });
var Ft = kt.object({ name: kt.string(), type: kt.literal("file"), value: kt.string() });
var Gt = kt.object({ name: kt.string(), type: kt.literal("color"), value: kt.string() });
var Tt = kt.object({ name: kt.string(), type: kt.literal("object"), value: kt.number() });
var Nt = kt.discriminatedUnion("type", [Dt, xt, Lt, St, Ft, Gt, Tt]);
var Rt = kt.object({ name: kt.string(), type: kt.literal("tilelayer"), class: kt.string().optional(), height: kt.number(), width: kt.number(), x: kt.number(), y: kt.number(), id: kt.number(), opacity: kt.number(), properties: kt.array(Nt).optional(), visible: kt.boolean(), tintcolor: kt.string().optional(), parallaxx: kt.number().optional(), parallaxy: kt.number().optional(), offsetx: kt.number().optional(), offsety: kt.number().optional() });
var Mt = Rt.extend({ data: kt.array(kt.number()), encoding: kt.literal("csv") });
var Ut = Rt.extend({ data: kt.array(kt.number()), encoding: kt.literal("base64"), compression: kt.literal("gzip") });
var Ot = Rt.extend({ data: kt.array(kt.number()), encoding: kt.literal("base64"), compression: kt.literal("zlib") });
var qt = Rt.extend({ data: kt.array(kt.number()), encoding: kt.literal("base64"), compression: kt.literal("zstandard") });
var jt = Rt.extend({ data: kt.string(), encoding: kt.literal("base64"), compression: kt.string().optional() });
var Jt = kt.object({ x: kt.number(), y: kt.number(), width: kt.number(), height: kt.number(), data: kt.string() });
var Zt = kt.object({ x: kt.number(), y: kt.number(), width: kt.number(), height: kt.number(), data: kt.array(kt.number()) });
var Yt = kt.union([Jt, Zt]);
var Ht = Rt.extend({ startx: kt.number(), starty: kt.number(), chunks: kt.array(Yt), encoding: kt.string().optional(), compression: kt.string().optional(), data: kt.undefined() });
var Kt = kt.union([jt, Mt, Ut, Ot, qt, Ht]);
function Pt(e2) {
  return "base64" === e2.encoding;
}
function zt(e2) {
  return "csv" === e2.encoding || Array.isArray(e2.data);
}
var Vt = kt.object({ x: kt.number(), y: kt.number() });
var Wt = kt.array(Vt);
var Xt = kt.object({ text: kt.string(), color: kt.string().optional(), fontfamily: kt.string().optional(), pixelsize: kt.number().optional(), wrap: kt.boolean().optional(), halign: kt.union([kt.literal("left"), kt.literal("center"), kt.literal("right"), kt.literal("justify")]).optional(), valign: kt.union([kt.literal("top"), kt.literal("center"), kt.literal("bottom")]).optional() });
var $t = kt.object({ id: kt.number().optional(), name: kt.string().optional(), type: kt.string().optional(), x: kt.number().optional(), y: kt.number().optional(), rotation: kt.number().optional(), height: kt.number().optional(), width: kt.number().optional(), visible: kt.boolean().optional(), gid: kt.number().optional(), text: Xt.optional(), point: kt.boolean().optional(), ellipse: kt.boolean().optional(), polyline: kt.array(Vt).optional(), polygon: Wt.optional(), template: kt.string().optional(), properties: kt.array(Nt).optional() });
var eA = kt.object({ duration: kt.number(), tileid: kt.number() });
var tA = kt.object({ name: kt.string(), draworder: kt.string(), type: kt.literal("objectgroup"), class: kt.string().optional(), x: kt.number(), y: kt.number(), id: kt.number(), color: kt.string().optional(), tintcolor: kt.string().optional(), parallaxx: kt.number().optional(), parallaxy: kt.number().optional(), offsetx: kt.number().optional(), offsety: kt.number().optional(), opacity: kt.number(), properties: kt.array(Nt).optional(), visible: kt.boolean(), objects: kt.array($t) });
var AA = kt.object({ name: kt.string(), x: kt.number(), y: kt.number(), id: kt.number(), type: kt.literal("imagelayer"), class: kt.string().optional(), image: kt.string().optional(), opacity: kt.number(), properties: kt.array(Nt).optional(), visible: kt.boolean(), tintcolor: kt.string().optional(), repeatx: kt.boolean().optional(), repeaty: kt.boolean().optional(), parallaxx: kt.number().optional(), parallaxy: kt.number().optional(), offsetx: kt.number().optional(), offsety: kt.number().optional(), transparentcolor: kt.string().optional() });
var iA = kt.union([Kt, AA, tA]);
var aA = kt.object({ draworder: kt.string(), id: kt.number().optional(), name: kt.string(), x: kt.number(), y: kt.number(), opacity: kt.number(), tintcolor: kt.string().optional(), type: kt.literal("objectgroup"), visible: kt.boolean(), objects: kt.array($t), properties: kt.array(Nt).optional() });
var sA = kt.object({ id: kt.number(), type: kt.string().optional(), animation: kt.array(eA).optional(), objectgroup: aA.optional(), probability: kt.number().optional(), properties: kt.array(Nt).optional(), image: kt.string().optional(), imageheight: kt.number().optional(), imagewidth: kt.number().optional() });
var rA = kt.object({ name: kt.string(), firstgid: kt.number().optional(), class: kt.string().optional(), objectalignment: kt.union([kt.literal("topleft"), kt.literal("top"), kt.literal("topright"), kt.literal("left"), kt.literal("center"), kt.literal("right"), kt.literal("bottomleft"), kt.literal("bottom"), kt.literal("bottomright")]).optional(), image: kt.string().optional(), imagewidth: kt.number().optional(), imageheight: kt.number().optional(), columns: kt.number(), tileheight: kt.number(), tilewidth: kt.number(), tilecount: kt.number(), grid: kt.object({ height: kt.number(), width: kt.number(), orientation: kt.union([kt.literal("isometric"), kt.literal("orthogonal")]) }).optional(), tileoffset: Vt.optional(), spacing: kt.number(), margin: kt.number(), tiles: kt.array(sA).optional(), properties: kt.array(Nt).optional() });
function nA(e2) {
  return !!e2.image;
}
function oA(e2) {
  return !e2.image;
}
var lA = rA.extend({ tiledversion: kt.string().optional(), type: kt.literal("tileset"), version: kt.string().optional() });
var gA = kt.object({ firstgid: kt.number(), source: kt.string() });
var dA = kt.union([rA, gA]);
var hA = kt.object({ object: $t.extend({ id: kt.number().optional() }), tileset: gA.optional(), type: kt.literal("template") });
var cA = kt.object({ type: kt.string(), class: kt.string().optional(), tiledversion: kt.string(), version: kt.string(), width: kt.number(), height: kt.number(), tilewidth: kt.number(), tileheight: kt.number(), compressionlevel: kt.number().optional(), infinite: kt.boolean(), nextlayerid: kt.number(), nextobjectid: kt.number(), parallaxoriginx: kt.number().optional(), parallaxoriginy: kt.number().optional(), hexsidelength: kt.number().optional(), staggeraxis: kt.literal("y").or(kt.literal("x")).optional(), staggerindex: kt.literal("odd").or(kt.literal("even")).optional(), orientation: kt.union([kt.literal("isometric"), kt.literal("orthogonal"), kt.literal("staggered"), kt.literal("hexagonal")]), renderorder: kt.union([kt.literal("right-down"), kt.literal("right-up"), kt.literal("left-down"), kt.literal("left-up")]), backgroundcolor: kt.string().optional(), layers: kt.array(iA), tilesets: kt.array(dA), properties: kt.array(Nt).optional() });
function IA(e2) {
  return !!e2.chunks;
}
function uA(e2) {
  return !e2.source;
}
function BA(e2) {
  return !!e2.source;
}
var CA = class _CA {
  constructor(e2, t, A2, i2) {
    this.x = e2, this.y = t, this.width = A2, this.height = i2;
  }
  combine(e2) {
    const t = this.x + this.width, A2 = this.y + this.height, i2 = e2.x + e2.width, a2 = e2.y + e2.height, s2 = Math.max(t, i2), r2 = Math.max(A2, a2);
    return new _CA(Math.min(this.x, e2.x), Math.min(this.y, e2.y), s2 - Math.min(this.x, e2.x), r2 - Math.min(this.y, e2.y));
  }
};
var pA = class {
  constructor() {
    this._largestBounds = new CA(0, 0, 0, 0);
  }
  _coerceNumber(e2) {
    return +e2;
  }
  _coerceBoolean(e2) {
    switch (e2) {
      case "0":
      case "false":
        return false;
      case "true":
        return true;
      default:
        return !!Boolean(e2);
    }
  }
  _coerceType(e2, t) {
    return "bool" === e2 ? this._coerceBoolean(t) : "int" === e2 || "float" === e2 || "object" === e2 ? this._coerceNumber(t) : t;
  }
  _parsePropertiesNode(e2, t) {
    var A2;
    const i2 = [];
    if (e2) for (let t2 of e2.children) {
      const e3 = null !== (A2 = t2.getAttribute("type")) && void 0 !== A2 ? A2 : "string";
      let a2 = t2.getAttribute("value");
      a2 || (a2 = t2.innerHTML), i2.push({ name: t2.getAttribute("name"), type: e3, value: this._coerceType(e3, a2) });
    }
    t.properties = i2;
  }
  _parseAttributes(e2, t) {
    const A2 = ["width", "height", "columns", "firstgid", "spacing", "margin", "tilecount", "tilewidth", "tileheight", "opacity", "compressionlevel", "nextlayerid", "nextobjectid", "parallaxoriginx", "parallaxoriginy", "parallaxx", "parallaxy", "hexsidelength", "offsetx", "offsety", "id", "gid", "x", "y", "rotation", "probability"], i2 = ["infinite", "visible", "repeatx", "repeaty"];
    for (let a2 of e2.attributes) A2.indexOf(a2.name) > -1 ? t[a2.name] = this._coerceNumber(a2.value) : i2.indexOf(a2.name) > -1 ? t[a2.name] = this._coerceBoolean(a2.value) : t[a2.name] = a2.value;
  }
  _parseToDocument(e2) {
    if ("undefined" != typeof DOMParser) {
      return new DOMParser().parseFromString(e2, "application/xml");
    }
    try {
      const { JSDOM: t2 } = a(371);
      return new t2(e2, { contentType: "application/xml", encoding: "utf-8" }).window.document;
    } catch (e3) {
    }
    const t = new Error("Could not find DOM parser");
    throw console.error(t.message, t), t;
  }
  parseObject(e2, t = true) {
    var A2, i2;
    const a2 = { type: "", x: 0, y: 0 };
    e2.getAttribute("template") || (a2.visible = true, a2.name = "", a2.rotation = 0, a2.height = 0, a2.width = 0), this._parseAttributes(e2, a2);
    const s2 = e2.querySelector("properties");
    s2 && this._parsePropertiesNode(s2, a2);
    const r2 = e2.querySelector("text");
    if (r2) {
      a2.text = { text: r2.textContent };
      const e3 = r2.getAttribute("fontfamily");
      e3 && (a2.text.fontfamily = e3);
      const t2 = r2.getAttribute("color");
      t2 && (a2.text.color = t2);
      const A3 = r2.getAttribute("pixelsize");
      A3 && (a2.text.pixelsize = this._coerceNumber(A3));
      const i3 = r2.getAttribute("wrap");
      i3 && (a2.text.wrap = this._coerceBoolean(i3));
      const s3 = r2.getAttribute("valign");
      s3 && (a2.text.valign = s3);
      const n3 = r2.getAttribute("halign");
      n3 && (a2.text.halign = n3);
    }
    e2.querySelector("point") && (a2.point = true);
    e2.querySelector("ellipse") && (a2.ellipse = true);
    const n2 = e2.querySelector("polygon");
    if (n2) {
      const e3 = null === (A2 = n2.getAttribute("points")) || void 0 === A2 ? void 0 : A2.split(" ");
      a2.polygon = [], e3 && e3.forEach((e4) => {
        const t2 = e4.split(",");
        a2.polygon.push({ x: +t2[0], y: +t2[1] });
      });
    }
    const o2 = e2.querySelector("polyline");
    if (o2) {
      const e3 = null === (i2 = o2.getAttribute("points")) || void 0 === i2 ? void 0 : i2.split(" ");
      a2.polyline = [], e3 && e3.forEach((e4) => {
        const t2 = e4.split(",");
        a2.polyline.push({ x: +t2[0], y: +t2[1] });
      });
    }
    if (t) try {
      return $t.parse(a2);
    } catch (e3) {
      throw console.error("Could not parse object", a2, e3), e3;
    }
    return a2;
  }
  parseTileset(e2, t = true) {
    const A2 = { spacing: 0, margin: 0 };
    if (this._parseAttributes(e2, A2), A2.source) try {
      return dA.parse(A2);
    } catch (e3) {
      console.error("Could not parse external tileset", A2, e3);
    }
    for (let i2 of e2.children) switch (i2.tagName) {
      case "properties":
        this._parsePropertiesNode(i2, A2);
        break;
      case "tileoffset": {
        const e3 = {};
        this._parseAttributes(i2, e3), A2.tileoffset = e3;
        break;
      }
      case "grid": {
        const e3 = {};
        this._parseAttributes(i2, e3), A2.grid = e3;
        break;
      }
      case "image":
        A2.image = i2.getAttribute("source"), A2.imagewidth = this._coerceNumber(i2.getAttribute("width")), A2.imageheight = this._coerceNumber(i2.getAttribute("height"));
        break;
      case "tile": {
        A2.tiles || (A2.tiles = []);
        const e3 = {};
        this._parseAttributes(i2, e3);
        for (let A3 of i2.children) switch (A3.tagName) {
          case "image":
            e3.image = A3.getAttribute("source"), e3.imagewidth = this._coerceNumber(A3.getAttribute("width")), e3.imageheight = this._coerceNumber(A3.getAttribute("height"));
            break;
          case "objectgroup": {
            const i3 = { type: "objectgroup", name: "", visible: true, x: 0, y: 0, opacity: 1, objects: [] };
            this._parseAttributes(A3, i3), e3.objectgroup = i3;
            for (let e4 of A3.children) {
              const A4 = this.parseObject(e4, t);
              i3.objects.push(A4);
            }
            break;
          }
          case "animation": {
            const t2 = [];
            for (let e4 of A3.children) t2.push({ duration: this._coerceNumber(e4.getAttribute("duration")), tileid: this._coerceNumber(e4.getAttribute("tileid")) });
            e3.animation = t2;
            break;
          }
          case "properties":
            this._parsePropertiesNode(A3, e3);
        }
        if (t) try {
          A2.tiles.push(sA.parse(e3));
        } catch (t2) {
          throw console.error("Could not parse Tile", e3, t2), t2;
        }
        else A2.tiles.push(e3);
        break;
      }
    }
    if (t) try {
      return dA.parse(A2);
    } catch (e3) {
      throw console.error("Could not parse Tileset", A2, e3), e3;
    }
    return A2;
  }
  parseTileLayer(e2, t, A2 = true) {
    var i2, a2, s2, r2;
    const n2 = { type: "tilelayer", x: 0, y: 0, opacity: 1, visible: true };
    this._parseAttributes(e2, n2);
    for (let A3 of e2.children) switch (A3.tagName) {
      case "properties":
        this._parsePropertiesNode(A3, n2);
        break;
      case "data": {
        const e3 = A3.getAttribute("encoding");
        e3 && (n2.encoding = e3);
        const o2 = A3.getAttribute("compression");
        if (o2 && (n2.compression = o2), t) {
          n2.width = 0, n2.height = 0, n2.chunks = [];
          let e4 = new CA(0, 0, 0, 0);
          for (let t2 of A3.children) if ("chunk" === t2.tagName) {
            const A4 = {};
            switch (this._parseAttributes(t2, A4), n2.encoding) {
              case "base64":
                A4.data = null === (i2 = t2.textContent) || void 0 === i2 ? void 0 : i2.trim();
                break;
              case "csv":
                A4.data = null === (a2 = t2.textContent) || void 0 === a2 ? void 0 : a2.split(",").map((e5) => +e5);
            }
            const s3 = new CA(A4.x, A4.y, A4.width, A4.height);
            e4 = e4.combine(s3), n2.chunks.push(A4);
          }
          n2.width = e4.width, n2.height = e4.height, n2.startx = e4.x, n2.starty = e4.y, this._largestBounds = this._largestBounds.combine(new CA(n2.startx, n2.starty, n2.width, n2.height));
        } else switch (n2.encoding) {
          case "base64":
            n2.data = null === (s2 = A3.textContent) || void 0 === s2 ? void 0 : s2.trim();
            break;
          case "csv":
            n2.data = null === (r2 = A3.textContent) || void 0 === r2 ? void 0 : r2.split(",").map((e4) => +e4);
        }
      }
    }
    if (A2) try {
      return iA.parse(n2);
    } catch (e3) {
      throw console.error("Could not parse tiled tile layer", n2, e3), e3;
    }
    return n2;
  }
  parseObjectGroup(e2, t = true) {
    const A2 = { type: "objectgroup", draworder: "topdown", visible: true, x: 0, y: 0, opacity: 1, objects: [] };
    this._parseAttributes(e2, A2);
    for (let i2 of e2.children) switch (i2.tagName) {
      case "properties":
        this._parsePropertiesNode(i2, A2);
        break;
      case "object": {
        const e3 = this.parseObject(i2, t);
        A2.objects.push(e3);
        break;
      }
    }
    if (t) try {
      return iA.parse(A2);
    } catch (e3) {
      throw console.error("Could not parse object group", A2, e3), e3;
    }
    return A2;
  }
  parseImageLayer(e2, t = true) {
    const A2 = { type: "imagelayer", visible: true, x: 0, y: 0, opacity: 1 }, i2 = e2.querySelector("image");
    A2.image = null == i2 ? void 0 : i2.getAttribute("source");
    const a2 = e2.querySelector("properties");
    a2 && this._parsePropertiesNode(a2, A2);
    const s2 = null == i2 ? void 0 : i2.getAttribute("trans");
    if (s2 && (A2.transparentcolor = "#" + s2), this._parseAttributes(e2, A2), t) try {
      return iA.parse(A2);
    } catch (e3) {
      throw console.error("Could not parse layer", A2, e3), e3;
    }
    return A2;
  }
  parseExternalTemplate(e2, t = true) {
    const A2 = this._parseToDocument(e2).querySelector("template"), i2 = { type: "template" }, a2 = A2.querySelector("object");
    a2 && (i2.object = this.parseObject(a2, t));
    const s2 = A2.querySelector("tileset");
    if (s2 && (i2.tileset = this.parseTileset(s2, t)), t) try {
      return hA.parse(i2);
    } catch (e3) {
      throw console.error("Could not parse template", i2, e3), e3;
    }
    return i2;
  }
  parseExternalTileset(e2, t = true) {
    const A2 = this._parseToDocument(e2).querySelector("tileset"), i2 = this.parseTileset(A2, t);
    if (i2.type = "tileset", this._parseAttributes(A2, i2), t) try {
      return lA.parse(i2);
    } catch (e3) {
      throw console.error("Could not parse tileset file", i2, e3), e3;
    }
    return i2;
  }
  parse(e2, t = true) {
    const A2 = this._parseToDocument(e2).querySelector("map"), i2 = { type: "map", compressionlevel: -1, layers: [], tilesets: [] };
    this._parseAttributes(A2, i2);
    const a2 = (e3, t2 = true) => {
      switch (e3.tagName) {
        case "group":
          for (let A3 of e3.children) a2(A3, t2);
          break;
        case "layer": {
          const A3 = this.parseTileLayer(e3, i2.infinite, t2);
          i2.layers.push(A3);
          break;
        }
        case "properties":
          this._parsePropertiesNode(e3, i2);
          break;
        case "tileset": {
          const A3 = this.parseTileset(e3, t2);
          i2.tilesets.push(A3);
          break;
        }
        case "objectgroup": {
          const A3 = this.parseObjectGroup(e3, t2);
          i2.layers.push(A3);
          break;
        }
        case "imagelayer": {
          const A3 = this.parseImageLayer(e3, t2);
          i2.layers.push(A3);
          break;
        }
      }
    };
    for (let e3 of A2.children) a2(e3, t);
    if (t) try {
      return cA.parse(i2);
    } catch (e3) {
      throw console.error("Could not parse Tiled map", e3), e3;
    }
    return i2;
  }
};
var fA = a(668);
var QA;
var EA;
var mA;
var yA = { env: { emscripten_notify_memory_growth: function(e2) {
  mA = new Uint8Array(EA.exports.memory.buffer);
} } };
var wA = class {
  init() {
    return QA || (QA = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + _A).then((e2) => e2.arrayBuffer()).then((e2) => WebAssembly.instantiate(e2, yA)).then(this._init) : WebAssembly.instantiate(Buffer.from(_A, "base64"), yA).then(this._init), QA);
  }
  _init(e2) {
    EA = e2.instance, yA.env.emscripten_notify_memory_growth(0);
  }
  decode(e2, t = 0) {
    if (!EA) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const A2 = e2.byteLength, i2 = EA.exports.malloc(A2);
    mA.set(e2, i2), t = t || Number(EA.exports.ZSTD_findDecompressedSize(i2, A2));
    const a2 = EA.exports.malloc(t), s2 = EA.exports.ZSTD_decompress(a2, t, i2, A2), r2 = mA.slice(a2, a2 + s2);
    return EA.exports.free(i2), EA.exports.free(a2), r2;
  }
};
var _A = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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";
var vA = class {
  static decode(e2, t) {
    var A2, i2, a2, s2, r2, n2;
    if (e2.length % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var o2 = "+".charCodeAt(0), l2 = "/".charCodeAt(0), g2 = "0".charCodeAt(0), d2 = "a".charCodeAt(0), h2 = "A".charCodeAt(0), c2 = "-".charCodeAt(0), I2 = "_".charCodeAt(0);
    function u2(e3) {
      var t2 = e3.charCodeAt(0);
      if (t2 === o2 || t2 === c2) return 62;
      if (t2 === l2 || t2 === I2) return 63;
      if (t2 < g2) return -1;
      if (t2 < g2 + 10) return t2 - g2 + 26 + 26;
      if (t2 < h2 + 26) return t2 - h2;
      if (t2 < d2 + 26) return t2 - d2 + 26;
      throw Error("Could not decode elt");
    }
    var B2 = e2.length;
    r2 = "=" === e2.charAt(B2 - 2) ? 2 : "=" === e2.charAt(B2 - 1) ? 1 : 0, n2 = new Uint8Array(3 * e2.length / 4 - r2), a2 = r2 > 0 ? e2.length - 4 : e2.length;
    var C2 = 0;
    function p2(e3) {
      n2[C2++] = e3;
    }
    for (A2 = 0, i2 = 0; A2 < a2; A2 += 4, i2 += 3) p2((16711680 & (s2 = u2(e2.charAt(A2)) << 18 | u2(e2.charAt(A2 + 1)) << 12 | u2(e2.charAt(A2 + 2)) << 6 | u2(e2.charAt(A2 + 3)))) >> 16), p2((65280 & s2) >> 8), p2(255 & s2);
    return 2 === r2 ? p2(255 & (s2 = u2(e2.charAt(A2)) << 2 | u2(e2.charAt(A2 + 1)) >> 4)) : 1 === r2 && (p2((s2 = u2(e2.charAt(A2)) << 10 | u2(e2.charAt(A2 + 1)) << 4 | u2(e2.charAt(A2 + 2)) >> 2) >> 8 & 255), p2(255 & s2)), new Promise((e3) => {
      const i3 = function(e4) {
        for (var t2 = 0, A3 = e4.length - 1; A3 >= 0; A3--) t2 = 256 * t2 + 1 * e4[A3];
        return t2;
      };
      if ("zlib" === t || "gzip" === t) {
        var a3 = (n2 = (0, fA.inflate)(n2)).length / 4, s3 = new Array(a3);
        for (A2 = 0; A2 < a3; A2++) s3[A2] = i3(n2.slice(4 * A2, 4 * A2 + 4));
        e3(s3);
      }
      if ("zstd" === t) {
        const t2 = new wA();
        t2.init().then(() => {
          var a4 = (n2 = t2.decode(n2)).length / 4, s4 = new Array(a4);
          for (A2 = 0; A2 < a4; A2++) s4[A2] = i3(n2.slice(4 * A2, 4 * A2 + 4));
          e3(s4);
        });
      }
      if (!t) {
        a3 = n2.length / 4, s3 = new Array(a3);
        for (A2 = 0; A2 < a3; A2++) s3[A2] = i3(n2.slice(4 * A2, 4 * A2 + 4));
        e3(s3);
      }
    });
  }
};
var bA = { TileData: { Tiled: "ex-tiled" }, ZIndex: { ZIndex: "zindex" }, Camera: { Camera: "camera", Zoom: "zoom" }, Animation: { Strategy: "animationstrategy" }, Layer: { Solid: "solid" }, Collision: { Type: "collisiontype" } };
var kA = async (e2, t) => {
  const A2 = await fetch(e2);
  switch (t.toLowerCase()) {
    case "xml":
    default:
      return await A2.text();
    case "json":
      return await A2.json();
  }
};
var DA = (e2) => (t) => (null == t ? void 0 : t.name) && e2 ? 0 === t.name.toLocaleLowerCase().localeCompare(e2.toLocaleLowerCase()) : (null == t ? void 0 : t.name) === e2;
var xA = (e2) => (t) => (null == t ? void 0 : t.class) && e2 ? 0 === t.class.toLocaleLowerCase().localeCompare(e2.toLocaleLowerCase()) : (null == t ? void 0 : t.class) === e2;
var LA = (e2, t) => (A2) => {
  const i2 = ((e3) => {
    const t2 = /* @__PURE__ */ new Map();
    for (let [A3, i3] of e3) {
      let e4 = i3;
      "string" == typeof i3 && (e4 = i3.toLocaleLowerCase()), t2.set(A3.toLocaleLowerCase(), e4);
    }
    return t2;
  })(A2.properties);
  if (void 0 !== t) {
    let A3 = t;
    return "string" == typeof t && (A3 = t.toLocaleLowerCase()), i2.get(e2.toLocaleLowerCase()) === A3;
  }
  return i2.has(e2.toLocaleLowerCase());
};
var SA = 2147483648;
var FA = 1073741824;
var GA = 536870912;
var TA = (e2) => !!(e2 & SA);
var NA = (e2) => !!(e2 & FA);
var RA = (e2) => !!(e2 & GA);
var MA = (e2) => e2 & ~(SA | FA | GA);
var UA = class {
  constructor(e2) {
    this.type = e2, this._loaded = false, this.cache = /* @__PURE__ */ new Map();
  }
  getOrAdd(...e2) {
    let t = this.cache.get(e2.join("+"));
    return t || (t = new this.type(...e2), this.cache.set(e2.join("+"), t), t);
  }
  values() {
    if (this._loaded) return Array.from(this.cache.values());
    throw new Error("Read through cache not yet loaded! No values to return!");
  }
  async load() {
    const e2 = Array.from(this.cache.entries()), t = await Promise.allSettled(e2.map((e3) => e3[1].load()));
    let A2 = 0;
    for (let i2 = 0; i2 < t.length; i2++) {
      const a2 = t[i2];
      "rejected" === a2.status && (console.error(`Error loading resource at ${e2[i2][0]}, is your pathMap correct? or your Tiled map corrupted?`, a2.reason), A2++);
    }
    if (A2) throw new Error(`Error loading ${A2} resources`);
    this._loaded = true;
  }
};
var OA = ((e2) => {
  var t = {};
  return a.d(t, e2), t;
})({ Actor: () => __webpack_exports__Actor, AffineMatrix: () => __webpack_exports__AffineMatrix, Animation: () => __webpack_exports__Animation, AnimationStrategy: () => __webpack_exports__AnimationStrategy, BaseAlign: () => __webpack_exports__BaseAlign, BodyComponent: () => __webpack_exports__BodyComponent, BoundingBox: () => __webpack_exports__BoundingBox, CollisionType: () => __webpack_exports__CollisionType, Color: () => __webpack_exports__Color, Component: () => __webpack_exports__Component, Font: () => __webpack_exports__Font, FontUnit: () => __webpack_exports__FontUnit, GraphicsComponent: () => __webpack_exports__GraphicsComponent, ImageSource: () => __webpack_exports__ImageSource, IsometricEntityComponent: () => __webpack_exports__IsometricEntityComponent, IsometricMap: () => __webpack_exports__IsometricMap, Logger: () => __webpack_exports__Logger, ParallaxComponent: () => __webpack_exports__ParallaxComponent, Shape: () => __webpack_exports__Shape, SpriteSheet: () => __webpack_exports__SpriteSheet, Text: () => __webpack_exports__Text, TextAlign: () => __webpack_exports__TextAlign, TileMap: () => __webpack_exports__TileMap, TransformComponent: () => __webpack_exports__TransformComponent, Vector: () => __webpack_exports__Vector, toRadians: () => __webpack_exports__toRadians, vec: () => __webpack_exports__vec });
function qA(e2, t) {
  try {
    if (t) for (const A2 of t) {
      let t2 = A2.value;
      "string" == typeof A2.value && (t2 = A2.value.toLocaleLowerCase()), e2.properties.set(A2.name.toLocaleLowerCase(), t2);
    }
  } catch (t2) {
    console.error(`Unable to map properties onto ${e2}`, t2);
  }
}
function jA(e2) {
  const t = e2.match(/[^/\\&\?]+\.\w{2,4}(?=([\#\?&].*$|$))/gi);
  if (t) {
    return t[0];
  }
  throw new Error(`Could not locate filename from path: ${e2}`);
}
function JA(e2, t) {
  for (const { path: A2, output: i2 } of t) if ("string" == typeof A2) {
    if (e2.includes(A2)) return i2;
  } else {
    const t2 = e2.match(A2);
    if (t2) return i2.replace("[match]", t2[0]);
  }
  return e2;
}
function ZA(e2, t) {
  if (!t) return false;
  for (const { path: A2, output: i2 } of t) if ("string" == typeof A2) {
    if (e2.includes(A2)) return true;
  } else {
    if (e2.match(A2)) return true;
  }
  return false;
}
function YA(e2, t, A2) {
  if (ZA(t, A2) && A2) return JA(t, A2);
  if (0 === t.indexOf("/")) return t;
  const i2 = e2.split("/"), a2 = t.split("/");
  return i2[i2.length - 1].includes(".") && i2.pop(), i2.concat(a2).join("/");
}
var HA = class {
  constructor(e2) {
    var t, A2, i2, a2;
    this.properties = /* @__PURE__ */ new Map(), this.tiledObject = e2.tiledObject, this.name = this.tiledObject.name, this.class = this.tiledObject.type, this.id = null !== (t = this.tiledObject.id) && void 0 !== t ? t : -1, this.x = null !== (A2 = this.tiledObject.x) && void 0 !== A2 ? A2 : 0, this.y = null !== (i2 = this.tiledObject.y) && void 0 !== i2 ? i2 : 0, this.rotation = null !== (a2 = this.tiledObject.rotation) && void 0 !== a2 ? a2 : 0;
  }
};
var KA = class extends HA {
  constructor(e2, t) {
    if (super({ tiledObject: e2 }), !e2.template) throw new Error("Invalid template");
    if (this.source = e2.template, this.gid = e2.gid, this.instanceObject = e2, this.template = t, t.object) {
      this.name = this.name || t.object.name, this.class = this.class || t.object.class;
      for (const [e3, A2] of t.object.properties.entries()) this.properties.has(e3) || this.properties.set(e3, A2);
    }
    if (t.tileset && t.object.tiledObject.gid) {
      const e3 = t.tileset.getTileByGid(t.object.tiledObject.gid);
      if (e3) {
        this.class = this.class || e3.class;
        for (const [t2, A2] of e3.properties.entries()) this.properties.has(t2) || this.properties.set(t2, A2);
      }
    }
  }
};
var PA = class extends HA {
  constructor(e2, t, A2, i2) {
    super({ tiledObject: e2 }), this.gid = t, this.width = A2, this.height = i2;
  }
};
var zA = class extends HA {
};
var VA = class extends HA {
  constructor(e2, t, A2, i2) {
    var a2, s2, r2;
    super({ tiledObject: e2 }), this.font = new OA.Font({ family: null !== (a2 = t.fontfamily) && void 0 !== a2 ? a2 : "sans-serif", color: t.color ? OA.Color.fromHex(t.color) : OA.Color.Black, size: null !== (s2 = t.pixelsize) && void 0 !== s2 ? s2 : 16, unit: OA.FontUnit.Px, textAlign: this._textAlignFromTiled(t.halign), baseAlign: this._textBaselineFromTiled(t.valign), quality: i2 });
    const n2 = null !== (r2 = t.wrap) && void 0 !== r2 && r2;
    this.text = new OA.Text({ text: t.text, font: this.font, ...n2 ? { maxWidth: A2 + 10 } : {} });
  }
  _textBaselineFromTiled(e2) {
    switch (e2) {
      case "bottom":
        return OA.BaseAlign.Bottom;
      case "center":
        return OA.BaseAlign.Middle;
      default:
        return OA.BaseAlign.Top;
    }
  }
  _textAlignFromTiled(e2) {
    switch (e2) {
      case "left":
      default:
        return OA.TextAlign.Left;
      case "center":
        return OA.TextAlign.Center;
      case "right":
        return OA.TextAlign.Right;
      case "justify":
        return OA.TextAlign.Start;
    }
  }
};
var WA = class extends HA {
  constructor(e2, t, A2) {
    super({ tiledObject: e2 }), this.width = t, this.height = A2;
  }
};
var XA = class extends HA {
  constructor(e2, t, A2, i2) {
    super({ tiledObject: e2 }), this.width = t, this.height = A2, this.anchor = i2;
  }
};
var $A = class extends HA {
  constructor(e2, t) {
    super({ tiledObject: e2 }), this.points = [], this.localPoints = [], this.localPoints = t.map((e3) => (0, OA.vec)(e3.x, e3.y)), this.points = t.map((e3) => (0, OA.vec)(e3.x, e3.y).rotate((0, OA.toRadians)(this.rotation)).add((0, OA.vec)(this.x, this.y)));
  }
};
var ei = class extends HA {
  constructor(e2, t) {
    super({ tiledObject: e2 }), this.points = [], this.points = t.map((e3) => (0, OA.vec)(e3.x, e3.y));
  }
};
function ti(e2, t) {
  var A2, i2, a2, s2;
  let r2;
  if (e2.point) r2 = new zA({ tiledObject: e2 });
  else if (e2.ellipse) e2.width && e2.height ? (r2 = new WA(e2, e2.width, e2.height), r2.x += e2.width / 2, r2.y += e2.height / 2) : r2 = new WA(e2, 20, 20);
  else if (e2.polygon) r2 = new $A(e2, e2.polygon);
  else if (e2.polyline) r2 = new ei(e2, e2.polyline);
  else if (e2.text) r2 = new VA(e2, e2.text, null !== (A2 = e2.width) && void 0 !== A2 ? A2 : 0, null !== (i2 = null == t ? void 0 : t.textQuality) && void 0 !== i2 ? i2 : 4);
  else if (e2.gid && !e2.template) {
    r2 = new PA(e2, e2.gid, null !== (a2 = e2.width) && void 0 !== a2 ? a2 : 0, null !== (s2 = e2.height) && void 0 !== s2 ? s2 : 0);
    const A3 = null == t ? void 0 : t.getTilesetForTileGid(e2.gid);
    let i3 = e2.type;
    if (A3) {
      const t2 = null == A3 ? void 0 : A3.getTileByGid(e2.gid);
      if (i3 = i3 || (null == t2 ? void 0 : t2.class), null == t2 ? void 0 : t2.properties) for (const [e3, A4] of t2.properties.entries()) r2.properties.has(e3) || r2.properties.set(e3, A4);
    }
    r2.class = i3;
  } else if (e2.template && t) {
    const A3 = t.templates.find((t2) => jA(t2.templatePath) === jA(e2.template));
    if (!A3) throw new Error(`Template object id ${e2.id} with name ${e2.name} is missing a loaded template file, there should be one loaded from ${e2.template}! Is your tiled map or template corrupted?`);
    r2 = new KA(e2, A3);
  } else r2 = e2.width && e2.height ? new XA(e2, e2.width, e2.height, OA.Vector.Zero) : new XA(e2, 20, 20, OA.Vector.Half);
  return qA(r2, e2.properties), r2;
}
function Ai(e2, t) {
  const A2 = [];
  for (const i2 of e2.objects) {
    let e3 = ti(i2, t);
    A2.push(e3);
  }
  return A2;
}
var ii = class {
  constructor(e2) {
    const { templatePath: t, object: A2, tiledTemplate: i2, tileset: a2 } = e2;
    this.templatePath = t, this.object = A2, this.tiledTemplate = i2, this.tileset = a2;
  }
};
var ai = class {
  constructor(e2) {
    this.objects = [], this.colliders = [], this.animation = [], this.properties = /* @__PURE__ */ new Map();
    const { id: t, tileset: A2, tiledTile: i2 } = e2;
    this.id = t, this.tileset = A2, this.tiledTile = i2, this.class = i2.type, qA(this, i2.properties), i2.objectgroup && i2.objectgroup.objects && (this.objects = Ai(i2.objectgroup)), i2.animation && (this.animation = i2.animation);
  }
};
var si = class {
  constructor(e2) {
    var t, A2, i2, a2, s2, r2, n2, o2, l2, g2;
    this.firstGid = -1, this.tileCount = 0, this.tileWidth = 0, this.tileHeight = 0, this.tileOffset = (0, OA.vec)(0, 0), this.tiles = [], this.objectalignment = "bottomleft", this.orientation = "orthogonal", this.properties = /* @__PURE__ */ new Map();
    const { name: d2, tiledTileset: h2, image: c2, tileToImage: I2, firstGid: u2 } = e2;
    if (this.name = d2, this.tiledTileset = h2, this.firstGid = u2, nA(h2)) {
      qA(this, h2.properties);
      const e3 = h2.spacing, o3 = Math.floor((h2.imagewidth + e3) / (h2.tilewidth + e3)), l3 = Math.floor((h2.imageheight + e3) / (h2.tileheight + e3));
      if (this.class = h2.class, this.orientation = null !== (A2 = null === (t = h2.grid) || void 0 === t ? void 0 : t.orientation) && void 0 !== A2 ? A2 : "orthogonal", this.horizontalFlipTransform = OA.AffineMatrix.identity().translate(h2.tilewidth, 0).scale(-1, 1), this.verticalFlipTransform = OA.AffineMatrix.identity().translate(0, h2.tileheight).scale(1, -1), this.diagonalFlipTransform = OA.AffineMatrix.identity().translate(0, 0).rotate(-Math.PI / 2).scale(-1, 1), this.objectalignment = null !== (i2 = h2.objectalignment) && void 0 !== i2 ? i2 : "orthogonal" === this.orientation ? "bottomleft" : "bottom", c2 && (this.spritesheet = OA.SpriteSheet.fromImageSource({ image: c2, grid: { rows: l3, columns: o3, spriteWidth: h2.tilewidth, spriteHeight: h2.tileheight }, spacing: { originOffset: { x: null !== (a2 = h2.margin) && void 0 !== a2 ? a2 : 0, y: null !== (s2 = h2.margin) && void 0 !== s2 ? s2 : 0 }, margin: { x: null !== (r2 = h2.spacing) && void 0 !== r2 ? r2 : 0, y: null !== (n2 = h2.spacing) && void 0 !== n2 ? n2 : 0 } } })), this.tileCount = h2.tilecount, this.tileWidth = h2.tilewidth, this.tileHeight = h2.tileheight, h2.tileoffset && (this.tileOffset = (0, OA.vec)(h2.tileoffset.x, h2.tileoffset.y)), h2.tiles) for (const e4 of h2.tiles) this.tiles.push(new ai({ id: e4.id, tileset: this, tiledTile: e4, image: c2 }));
    }
    if (oA(h2) && void 0 !== h2.firstgid) {
      this.horizontalFlipTransform = OA.AffineMatrix.identity().translate(h2.tilewidth, 0).scale(-1, 1), this.verticalFlipTransform = OA.AffineMatrix.identity().translate(0, h2.tileheight).scale(1, -1), this.diagonalFlipTransform = OA.AffineMatrix.identity().translate(0, 0).rotate(-Math.PI / 2).scale(-1, 1), this.objectalignment = null !== (o2 = h2.objectalignment) && void 0 !== o2 ? o2 : "orthogonal" === this.orientation ? "bottomleft" : "bottom", this.orientation = null !== (g2 = null === (l2 = h2.grid) || void 0 === l2 ? void 0 : l2.orientation) && void 0 !== g2 ? g2 : "orthogonal", this.tileCount = h2.tilecount, this.tileWidth = h2.tilewidth, this.tileHeight = h2.tileheight, h2.tileoffset && (this.tileOffset = (0, OA.vec)(h2.tileoffset.x, h2.tileoffset.y));
      let e3 = [];
      if (h2.tiles) for (const t2 of h2.tiles) {
        const A3 = null == I2 ? void 0 : I2.get(t2);
        A3 && e3.push(A3.toSprite()), this.tiles.push(new ai({ id: t2.id, tileset: this, tiledTile: t2, image: A3 }));
      }
      I2 && (this.spritesheet = new OA.SpriteSheet({ sprites: e3 }));
    }
  }
  getTilesetAlignmentAnchor(e2) {
    switch (null != e2 ? e2 : this.objectalignment) {
      case "topleft":
        return (0, OA.vec)(0, 0);
      case "top":
        return (0, OA.vec)(0.5, 0);
      case "topright":
        return (0, OA.vec)(1, 0);
      case "left":
        return (0, OA.vec)(0, 0.5);
      case "center":
        return (0, OA.vec)(0.5, 0.5);
      case "right":
        return (0, OA.vec)(1, 0.5);
      case "bottomleft":
      default:
        return (0, OA.vec)(0, 1);
      case "bottom":
        return (0, OA.vec)(0.5, 1);
      case "bottomright":
        return (0, OA.vec)(1, 1);
    }
  }
  getTileByGid(e2) {
    const t = MA(e2) - this.firstGid;
    return this.tiles.find((e3) => e3.id === t);
  }
  getTilesByClassName(e2) {
    return this.tiles.filter(xA(e2));
  }
  getTilesByProperty(e2, t) {
    return this.tiles.filter(LA(e2, t));
  }
  getSpriteForGid(e2) {
    const t = TA(e2), A2 = NA(e2), i2 = RA(e2), a2 = MA(e2), s2 = a2 - this.firstGid;
    if (this.spritesheet) {
      let e3 = this.spritesheet.sprites[s2];
      return (i2 || t || A2) && (e3 = e3.clone()), i2 && (e3.rotation = -Math.PI / 2, e3.scale = (0, OA.vec)(-1, 1)), t && (e3.scale = (0, OA.vec)((i2 ? 1 : -1) * e3.scale.x, (i2 ? -1 : 1) * e3.scale.y)), A2 && (e3.scale = (0, OA.vec)((i2 ? -1 : 1) * e3.scale.x, (i2 ? 1 : -1) * e3.scale.y)), e3;
    }
    throw new Error(`Tileset: [${this.name}] Could not find sprite for gid: [${e2}] normalized gid: [${a2}]`);
  }
  _isometricTiledCoordToWorld(e2) {
    const t = this.tileWidth, A2 = this.tileHeight / 2, i2 = e2.y / A2, a2 = e2.x / A2;
    return (0, OA.vec)((a2 - i2) * t / 2 + 0, (a2 + i2) * A2 / 2);
  }
  getCollidersForGid(e2, t) {
    let { anchor: A2, scale: i2, orientationOverride: a2, offset: s2 } = { anchor: OA.Vector.Zero, scale: OA.Vector.One, offset: OA.Vector.Zero, orientationOverride: void 0, ...t };
    const r2 = null != a2 ? a2 : this.orientation, n2 = this.getTileByGid(e2), o2 = [];
    if (n2 && n2.objects) for (let t2 of n2.objects) {
      if (t2 instanceof $A) {
        let A3 = t2.points.map((e3) => e3.scale(i2));
        A3 = this._applyFlipsToPoints(A3, e2), "isometric" === r2 && (A3 = A3.map((e3) => this._isometricTiledCoordToWorld(e3))), A3 = A3.map((e3) => e3.add(s2));
        let a3 = OA.Shape.Polygon(A3, OA.Vector.Zero, true);
        a3.isConvex() ? o2.push(a3) : o2.push(a3.triangulate());
      }
      if (t2 instanceof XA) {
        const A3 = t2.width, a3 = t2.height, n3 = t2.anchor;
        let l2 = OA.BoundingBox.fromDimension(A3 * i2.x, a3 * i2.y, n3).getPoints().map((e3) => e3.rotate((0, OA.toRadians)(t2.rotation)).add((0, OA.vec)(t2.x, t2.y)));
        "isometric" === r2 && (l2 = l2.map((e3) => this._isometricTiledCoordToWorld(e3))), l2 = this._applyFlipsToPoints(l2, e2), l2 = l2.map((e3) => e3.add(s2));
        const g2 = OA.Shape.Polygon(l2);
        o2.push(g2);
      }
      if (t2 instanceof WA) {
        let e3 = (0, OA.vec)(t2.x, t2.y);
        "isometric" === r2 && (e3 = this._isometricTiledCoordToWorld(e3)), e3 = e3.add(s2);
        const A3 = Math.min(t2.width / 2, t2.height / 2), a3 = OA.Shape.Circle(A3, e3.scale(i2));
        o2.push(a3);
      }
    }
    return o2;
  }
  _applyFlipsToPoints(e2, t) {
    const A2 = TA(t), i2 = NA(t);
    return RA(t) && (e2 = e2.map((e3) => this.diagonalFlipTransform.multiply(e3))), A2 && (e2 = e2.map((e3) => this.horizontalFlipTransform.multiply(e3))), i2 && (e2 = e2.map((e3) => this.verticalFlipTransform.multiply(e3))), e2;
  }
  getAnimationForGid(e2) {
    var t;
    const A2 = this.getTileByGid(e2);
    if (A2 && (null === (t = A2.animation) || void 0 === t ? void 0 : t.length)) {
      let e3 = [];
      for (let t2 of A2.animation) e3.push({ graphic: this.getSpriteForGid(t2.tileid + this.firstGid), duration: t2.duration });
      return new OA.Animation({ frames: e3, strategy: OA.AnimationStrategy.Loop });
    }
    return null;
  }
};
var ri = class {
  constructor(e2, t, A2) {
    this.path = e2, this.strict = true, this.headless = false, this.orientation = "orthogonal", this.fileLoader = kA;
    const { fileLoader: i2, parser: a2, pathMap: s2, imageLoader: r2, strict: n2, headless: o2, orientation: l2 } = { ...A2 };
    this.headless = null != o2 ? o2 : this.headless, this.orientation = null != l2 ? l2 : this.orientation, this.strict = null != n2 ? n2 : this.strict, this.fileLoader = null != i2 ? i2 : this.fileLoader, this.imageLoader = null != r2 ? r2 : new UA(OA.ImageSource), this.parser = null != a2 ? a2 : new pA(), this.firstGid = t, this.pathMap = s2;
  }
  async load() {
    const e2 = this.path.includes(".tsx") ? "xml" : "json";
    try {
      const t = await this.fileLoader(this.path, e2);
      let A2;
      if (A2 = "json" === e2 ? this.strict ? lA.parse(t) : t : this.parser.parseExternalTileset(t, this.strict), nA(A2)) {
        const e3 = YA(this.path, A2.image, this.pathMap), t2 = this.headless ? void 0 : this.imageLoader.getOrAdd(e3);
        this.data = new si({ name: A2.name, tiledTileset: A2, firstGid: this.firstGid, image: t2 });
      }
      if (oA(A2)) {
        const e3 = this.headless ? void 0 : /* @__PURE__ */ new Map();
        if (e3) {
          const t2 = [];
          if (A2.tiles) {
            for (let i2 of A2.tiles) if (i2.image) {
              const A3 = YA(this.path, i2.image, this.pathMap), a2 = this.imageLoader.getOrAdd(A3);
              e3.set(i2, a2), t2.push(a2);
            }
          }
        }
        A2.firstgid = this.firstGid, this.data = new si({ name: A2.name, tiledTileset: A2, firstGid: this.firstGid, tileToImage: e3 });
      }
      if (this.headless || await this.imageLoader.load(), this.data) return this.data;
    } catch (e3) {
      throw console.error(`Could not load tileset at path ${this.path}`), e3;
    }
    throw new Error(`No tileset at path ${this.path}`);
  }
  isLoaded() {
    return !!this.data;
  }
};
var ni = class {
  constructor(e2, t) {
    this.templatePath = e2, this.headless = false, this.strict = true, this.fileLoader = kA;
    const { fileLoader: A2, parser: i2, pathMap: a2, imageLoader: s2, strict: r2, headless: n2 } = { ...t };
    this.headless = null != n2 ? n2 : this.headless, this.strict = null != r2 ? r2 : this.strict, this.fileLoader = null != A2 ? A2 : this.fileLoader, this.imageLoader = null != s2 ? s2 : new UA(OA.ImageSource), this.parser = null != i2 ? i2 : new pA(), this.pathMap = a2;
  }
  isLoaded() {
    return !!this.data;
  }
  async load() {
    const e2 = this.templatePath.includes(".tx") ? "xml" : "json";
    try {
      const t = await this.fileLoader(this.templatePath, e2);
      let A2;
      A2 = "xml" === e2 ? this.parser.parseExternalTemplate(t, this.strict) : this.strict ? hA.parse(t) : t;
      const i2 = A2, a2 = ti(A2.object);
      let s2;
      if (A2.tileset) {
        const e3 = YA(this.templatePath, A2.tileset.source, this.pathMap), t2 = new ri(e3, A2.tileset.firstgid, { headless: this.headless, strict: this.strict, fileLoader: this.fileLoader, imageLoader: this.imageLoader, parser: this.parser, pathMap: this.pathMap });
        s2 = await t2.load();
      }
      return this.data = new ii({ templatePath: this.templatePath, tiledTemplate: i2, object: a2, tileset: s2 });
    } catch (e3) {
      throw console.error(`Could not load template at ${this.templatePath}, check to see if your pathMap is correct or if you're Tiled map is corrupted`), e3;
    }
  }
};
var oi = class extends OA.Component {
  constructor(e2) {
    super();
    const { tiledObject: t } = e2;
    this.tiledObject = t;
  }
};
var li = class extends OA.Component {
  constructor(e2) {
    super();
    const { tiledTileLayer: t } = e2;
    this.tiledTileLayer = t;
  }
};
var gi = class {
  constructor(e2, t, A2) {
    this.tiledTileLayer = e2, this.resource = t, this.order = A2, this.logger = OA.Logger.getInstance(), this.width = 0, this.height = 0, this.properties = /* @__PURE__ */ new Map(), this.data = [], this._gidToTileInfo = /* @__PURE__ */ new Map(), this.name = e2.name, this.id = e2.id, this.class = e2.class, this.width = e2.width, this.height = e2.height, this.visible = !!e2.visible, qA(this, e2.properties);
  }
  getTilesByGid(e2) {
    var t;
    return null !== (t = this._gidToTileInfo.get(e2)) && void 0 !== t ? t : [];
  }
  getTilesByClassName(e2) {
    return this.isometricMap.tiles.filter((t) => {
      const A2 = t.data.get(bA.TileData.Tiled);
      return !!A2 && xA(e2)(A2);
    }).map((e3) => ({ exTile: e3, tiledTile: e3.data.get(bA.TileData.Tiled) }));
  }
  getTilesByProperty(e2, t) {
    return this.isometricMap.tiles.filter((A2) => {
      const i2 = A2.data.get(bA.TileData.Tiled);
      return !!i2 && LA(e2, t)(i2);
    }).map((e3) => ({ exTile: e3, tiledTile: e3.data.get(bA.TileData.Tiled) }));
  }
  getTileByPoint(e2) {
    if (!this.isometricMap) return this.logger.warn("IsometricMap has not yet been loaded! getTileByPoint() will only return null"), null;
    if (this.isometricMap) {
      const t = this.isometricMap.getTileByPoint(e2);
      if (!t) return null;
      const A2 = this.isometricMap.tiles.indexOf(t), i2 = MA(this.data[A2]);
      if (i2 <= 0) return null;
      return { tiledTile: this.resource.getTilesetForTileGid(i2).getTileByGid(i2), exTile: t };
    }
    return null;
  }
  _recordTileData(e2, t) {
    let A2 = this._gidToTileInfo.get(e2), i2 = this.resource.getTilesetForTileGid(e2).getTileByGid(e2);
    A2 ? A2.push({ exTile: t, tiledTile: i2 }) : A2 = [{ exTile: t, tiledTile: i2 }], this._gidToTileInfo.set(e2, A2), t.data.set(bA.TileData.Tiled, i2);
  }
  updateTile(e2, t, A2, i2, a2) {
    this._recordTileData(t, e2);
    const s2 = this.resource.getLayerConfig(this.name) || this.resource.getLayerConfig(this.id);
    void 0 !== (null == s2 ? void 0 : s2.isSolid) && (a2 = s2.isSolid), this.resource.useExcaliburWiring && a2 && (e2.solid = true);
    const r2 = e2.get(OA.IsometricEntityComponent);
    r2 && (r2.elevation = this.order);
    const n2 = this.resource.getTilesetForTileGid(t);
    let o2 = n2.getSpriteForGid(t);
    A2 && (o2 = o2.clone(), o2.tint = i2), e2.addGraphic(o2, { offset: n2.tileOffset });
    let l2 = e2.pos;
    if ("orthogonal" === n2.orientation) l2 = (0, OA.vec)(0, 0);
    else {
      const e3 = this.resource.map.tilewidth / 2, t2 = this.resource.map.tileheight;
      l2 = (0, OA.vec)(e3, t2);
    }
    const g2 = n2.getCollidersForGid(t, { offset: l2 });
    for (let t2 of g2) e2.addCollider(t2);
    (null == s2 ? void 0 : s2.useTileColliders) && g2.length > 0 && this.visible && (e2.solid = true), (null == s2 ? void 0 : s2.useTileCollidersWhenInvisible) && g2.length > 0 && (e2.solid = true);
    let d2 = n2.getAnimationForGid(t);
    if (d2 && (A2 && (d2 = d2.clone(), d2.tint = i2), e2.clearGraphics(), e2.addGraphic(d2, { offset: n2.tileOffset }), this.resource.useExcaliburWiring)) {
      const e3 = n2.getTileByGid(t), A3 = null == e3 ? void 0 : e3.properties.get(bA.Animation.Strategy);
      if (A3 && "string" == typeof A3) switch (A3.toLowerCase()) {
        case OA.AnimationStrategy.End.toLowerCase():
          d2.strategy = OA.AnimationStrategy.End;
          break;
        case OA.AnimationStrategy.Freeze.toLowerCase():
          d2.strategy = OA.AnimationStrategy.Freeze;
          break;
        case OA.AnimationStrategy.Loop.toLowerCase():
          d2.strategy = OA.AnimationStrategy.Loop;
          break;
        case OA.AnimationStrategy.PingPong.toLowerCase():
          d2.strategy = OA.AnimationStrategy.PingPong;
          break;
        default:
          this.logger.warn(`Unknown animation strategy in tileset ${n2.name} on tile gid ${t}: ${A3}`);
      }
    }
  }
  async load() {
    var e2, t, A2, i2;
    const a2 = this.resource.getLayerConfig(this.name) || this.resource.getLayerConfig(this.id), s2 = this.tiledTileLayer, r2 = !!this.properties.get(bA.Layer.Solid), n2 = (this.tiledTileLayer.opacity, !!this.tiledTileLayer.tintcolor), o2 = this.tiledTileLayer.tintcolor ? OA.Color.fromHex(this.tiledTileLayer.tintcolor) : OA.Color.Transparent, l2 = (0, OA.vec)(null !== (e2 = s2.offsetx) && void 0 !== e2 ? e2 : 0, null !== (t = s2.offsety) && void 0 !== t ? t : 0);
    this.tiledTileLayer.data && Pt(this.tiledTileLayer) ? this.data = await vA.decode(this.tiledTileLayer.data, this.tiledTileLayer.compression) : this.tiledTileLayer.data && zt(this.tiledTileLayer) && (this.data = this.tiledTileLayer.data);
    let g2 = this.order, d2 = this.properties.get(bA.ZIndex.ZIndex);
    if ("number" == typeof d2 && (g2 = d2), this.resource.map.infinite && IA(this.tiledTileLayer)) {
      const e3 = this.resource.isometricTiledCoordToWorld(this.tiledTileLayer.startx, this.tiledTileLayer.starty), t2 = (0, OA.vec)(e3.x * this.resource.map.tilewidth, e3.y * this.resource.map.tileheight);
      if (this.isometricMap = new OA.IsometricMap({ name: this.name, pos: l2.add(t2), tileHeight: this.resource.map.tileheight, tileWidth: this.resource.map.tilewidth, columns: s2.width, rows: s2.height, elevation: g2 }), null == a2 ? void 0 : a2.collisionGroup) {
        this.isometricMap.get(OA.BodyComponent).group = a2.collisionGroup;
      }
    } else if (this.isometricMap = new OA.IsometricMap({ name: this.name, pos: l2, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight, columns: s2.width, rows: s2.height, elevation: g2 }), null == a2 ? void 0 : a2.collisionGroup) {
      this.isometricMap.get(OA.BodyComponent).group = a2.collisionGroup;
    }
    if (this.isometricMap.visible = this.tiledTileLayer.visible, this.isometricMap.opacity = this.tiledTileLayer.opacity, this.isometricMap.addComponent(new li({ tiledTileLayer: s2 })), s2.parallaxx || s2.parallaxy) {
      const e3 = (0, OA.vec)(null !== (A2 = s2.parallaxx) && void 0 !== A2 ? A2 : 1, null !== (i2 = s2.parallaxy) && void 0 !== i2 ? i2 : 1);
      this.isometricMap.addComponent(new OA.ParallaxComponent(e3));
    }
    if (this.resource.map.infinite && IA(this.tiledTileLayer)) {
      const e3 = this.tiledTileLayer;
      for (let t2 of this.tiledTileLayer.chunks) {
        let A3 = [];
        Pt(this.tiledTileLayer) ? A3 = await vA.decode(t2.data, e3.compression) : zt(this.tiledTileLayer) && (A3 = t2.data);
        for (let e4 = 0; e4 < A3.length; e4++) {
          const i3 = A3[e4];
          if (0 != i3) {
            const A4 = e4 % t2.width + (t2.x - this.tiledTileLayer.startx), a3 = Math.floor(e4 / t2.width) + (t2.y - this.tiledTileLayer.starty), l3 = this.isometricMap.tiles[A4 + a3 * s2.width];
            this.updateTile(l3, i3, n2, o2, r2);
          }
        }
      }
    } else for (let e3 = 0; e3 < this.data.length; e3++) {
      let t2 = this.data[e3];
      if (0 !== t2) {
        const A3 = this.isometricMap.tiles[e3];
        this.updateTile(A3, t2, n2, o2, r2);
      }
    }
  }
};
var di = class {
  getTilesByGid(e2) {
    var t;
    return null !== (t = this._gidToTileInfo.get(e2)) && void 0 !== t ? t : [];
  }
  getTilesByClassName(e2) {
    return this.tilemap.tiles.filter((t) => {
      const A2 = t.data.get(bA.TileData.Tiled);
      return !!A2 && xA(e2)(A2);
    }).map((e3) => ({ exTile: e3, tiledTile: e3.data.get(bA.TileData.Tiled) }));
  }
  getTilesByProperty(e2, t) {
    return this.tilemap.tiles.filter((A2) => {
      const i2 = A2.data.get(bA.TileData.Tiled);
      return !!i2 && LA(e2, t)(i2);
    }).map((e3) => ({ exTile: e3, tiledTile: e3.data.get(bA.TileData.Tiled) }));
  }
  getTileByPoint(e2) {
    if (!this.tilemap) return this.logger.warn("Tilemap has not yet been loaded! getTileByPoint() will only return null"), null;
    if (this.tilemap) {
      const t = this.tilemap.getTileByPoint(e2);
      if (!t) return null;
      const A2 = this.tilemap.tiles.indexOf(t), i2 = MA(this.data[A2]);
      if (i2 <= 0) return null;
      return { tiledTile: this.resource.getTilesetForTileGid(i2).getTileByGid(i2), exTile: t };
    }
    return null;
  }
  getTileByCoordinate(e2, t) {
    if (!this.tilemap) return this.logger.warn("Tilemap has not yet been loaded! getTileByCoordinate() will only return null"), null;
    if (this.tilemap) {
      const A2 = this.tilemap.getTile(e2, t), i2 = this.tilemap.tiles.indexOf(A2), a2 = MA(this.data[i2]);
      if (a2 <= 0) return null;
      return { tiledTile: this.resource.getTilesetForTileGid(a2).getTileByGid(a2), exTile: A2 };
    }
    return null;
  }
  constructor(e2, t, A2) {
    this.tiledTileLayer = e2, this.resource = t, this.order = A2, this.logger = OA.Logger.getInstance(), this.width = 0, this.height = 0, this.properties = /* @__PURE__ */ new Map(), this.data = [], this._gidToTileInfo = /* @__PURE__ */ new Map(), this.name = e2.name, this.id = e2.id, this.class = e2.class, this.width = e2.width, this.height = e2.height, this.visible = !!e2.visible, qA(this, e2.properties);
  }
  _recordTileData(e2, t) {
    let A2 = this._gidToTileInfo.get(e2), i2 = this.resource.getTilesetForTileGid(e2).getTileByGid(e2);
    A2 ? A2.push({ exTile: t, tiledTile: i2 }) : A2 = [{ exTile: t, tiledTile: i2 }], this._gidToTileInfo.set(e2, A2), t.data.set(bA.TileData.Tiled, i2);
  }
  updateTile(e2, t, A2, i2, a2) {
    this._recordTileData(t, e2);
    const s2 = this.resource.getLayerConfig(this.name) || this.resource.getLayerConfig(this.id);
    void 0 !== (null == s2 ? void 0 : s2.isSolid) && (a2 = s2.isSolid), this.resource.useExcaliburWiring && a2 && this.visible && (e2.solid = true);
    const r2 = this.resource.getTilesetForTileGid(t), n2 = this.resource.headless;
    if (!n2) {
      let a3 = r2.getSpriteForGid(t);
      A2 && (a3 = a3.clone(), a3.tint = i2), e2.addGraphic(a3, { offset: r2.tileOffset });
    }
    const o2 = r2.getCollidersForGid(t);
    for (let t2 of o2) e2.addCollider(t2);
    (null == s2 ? void 0 : s2.useTileColliders) && o2.length > 0 && this.visible && (e2.solid = true), (null == s2 ? void 0 : s2.useTileCollidersWhenInvisible) && o2.length > 0 && (e2.solid = true);
    let l2 = n2 ? null : r2.getAnimationForGid(t);
    if (l2 && (A2 && (l2 = l2.clone(), l2.tint = i2), e2.clearGraphics(), e2.addGraphic(l2, { offset: r2.tileOffset }), this.resource.useExcaliburWiring)) {
      const e3 = r2.getTileByGid(t), A3 = null == e3 ? void 0 : e3.properties.get(bA.Animation.Strategy);
      if (A3 && "string" == typeof A3) switch (A3.toLowerCase()) {
        case OA.AnimationStrategy.End.toLowerCase():
          l2.strategy = OA.AnimationStrategy.End;
          break;
        case OA.AnimationStrategy.Freeze.toLowerCase():
          l2.strategy = OA.AnimationStrategy.Freeze;
          break;
        case OA.AnimationStrategy.Loop.toLowerCase():
          l2.strategy = OA.AnimationStrategy.Loop;
          break;
        case OA.AnimationStrategy.PingPong.toLowerCase():
          l2.strategy = OA.AnimationStrategy.PingPong;
          break;
        default:
          this.logger.warn(`Unknown animation strategy in tileset ${r2.name} on tile gid ${t}: ${A3}`);
      }
    }
  }
  async load() {
    var e2, t, A2, i2;
    const a2 = this.resource.getLayerConfig(this.name) || this.resource.getLayerConfig(this.id), s2 = this.tiledTileLayer.opacity, r2 = !!this.tiledTileLayer.tintcolor, n2 = this.tiledTileLayer.tintcolor ? OA.Color.fromHex(this.tiledTileLayer.tintcolor) : OA.Color.Transparent, o2 = !!this.properties.get(bA.Layer.Solid), l2 = this.tiledTileLayer, g2 = (0, OA.vec)(null !== (e2 = l2.offsetx) && void 0 !== e2 ? e2 : 0, null !== (t = l2.offsety) && void 0 !== t ? t : 0);
    if (this.tiledTileLayer.data && Pt(this.tiledTileLayer) ? this.data = await vA.decode(this.tiledTileLayer.data, this.tiledTileLayer.compression) : this.tiledTileLayer.data && zt(this.tiledTileLayer) && (this.data = this.tiledTileLayer.data), this.resource.map.infinite && IA(this.tiledTileLayer)) {
      const e3 = (0, OA.vec)(this.tiledTileLayer.startx * this.resource.map.tilewidth, this.tiledTileLayer.starty * this.resource.map.tileheight);
      if (this.tilemap = new OA.TileMap({ name: this.name, pos: g2.add(e3), tileHeight: this.resource.map.tileheight, tileWidth: this.resource.map.tilewidth, columns: l2.width, rows: l2.height }), null == a2 ? void 0 : a2.collisionGroup) {
        this.tilemap.get(OA.BodyComponent).group = a2.collisionGroup;
      }
    } else if (this.tilemap = new OA.TileMap({ name: this.name, pos: g2, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight, columns: l2.width, rows: l2.height }), null == a2 ? void 0 : a2.collisionGroup) {
      this.tilemap.get(OA.BodyComponent).group = a2.collisionGroup;
    }
    this.tilemap.addComponent(new li({ tiledTileLayer: l2 }));
    const d2 = this.tilemap.get(OA.TransformComponent);
    if (d2) {
      d2.z = this.order;
      let e3 = this.properties.get(bA.ZIndex.ZIndex);
      "number" == typeof e3 && (d2.z = e3);
    }
    const h2 = this.tilemap.get(OA.GraphicsComponent);
    if (h2 && (h2.isVisible = this.tiledTileLayer.visible, h2.opacity = s2), l2.parallaxx || l2.parallaxy) {
      const e3 = (0, OA.vec)(null !== (A2 = l2.parallaxx) && void 0 !== A2 ? A2 : 1, null !== (i2 = l2.parallaxy) && void 0 !== i2 ? i2 : 1);
      this.tilemap.addComponent(new OA.ParallaxComponent(e3));
    }
    if (this.resource.map.infinite && IA(this.tiledTileLayer)) {
      const e3 = this.tiledTileLayer;
      for (let t2 of this.tiledTileLayer.chunks) {
        let A3 = [];
        Pt(this.tiledTileLayer) ? A3 = await vA.decode(t2.data, e3.compression) : zt(this.tiledTileLayer) && (A3 = t2.data);
        for (let e4 = 0; e4 < A3.length; e4++) {
          const i3 = A3[e4];
          if (0 != i3) {
            const A4 = e4 % t2.width + (t2.x - this.tiledTileLayer.startx), a3 = Math.floor(e4 / t2.width) + (t2.y - this.tiledTileLayer.starty), s3 = this.tilemap.tiles[A4 + a3 * l2.width];
            this.updateTile(s3, i3, r2, n2, o2);
          }
        }
      }
    } else for (let e3 = 0; e3 < this.data.length; e3++) {
      let t2 = this.data[e3];
      if (0 !== t2) {
        const A3 = this.tilemap.tiles[e3];
        this.updateTile(A3, t2, r2, n2, o2);
      }
    }
  }
};
var hi = class {
  constructor(e2, t, A2) {
    this.tiledObjectLayer = e2, this.resource = t, this.order = A2, this.logger = OA.Logger.getInstance(), this.properties = /* @__PURE__ */ new Map(), this.objects = [], this.entities = [], this._objectToEntity = /* @__PURE__ */ new Map(), this._entityToObject = /* @__PURE__ */ new Map(), this._loaded = false, this.name = e2.name, this.class = e2.class, qA(this, e2.properties);
  }
  _logLoadedWarning(e2) {
    this.logger.warn(`ObjectLayer ${this.name} is not yet loaded, ${e2}() will always be empty!`);
  }
  getObjectsByName(e2) {
    return this._loaded || this._logLoadedWarning("getObjectsByName"), this.objects.filter(DA(e2));
  }
  getEntitiesByName(e2) {
    return this._loaded || this._logLoadedWarning("getEntitiesByName"), this.entities.filter(DA(e2));
  }
  getEntityByObject(e2) {
    return this._loaded || this._logLoadedWarning("getEntityByObject"), this._objectToEntity.get(e2);
  }
  getObjectByEntity(e2) {
    return this._loaded || this._logLoadedWarning("getObjectByEntity"), this._entityToObject.get(e2);
  }
  getObjectsByProperty(e2, t) {
    return this._loaded || this._logLoadedWarning("getObjectsByProperty"), this.objects.filter(LA(e2, t));
  }
  getEntitiesByProperty(e2, t) {
    return this._loaded || this._logLoadedWarning("getEntitiesByProperty"), this.getObjectsByProperty(e2, t).map((e3) => this._objectToEntity.get(e3)).filter((e3) => !!e3);
  }
  getObjectsByClassName(e2) {
    return this._loaded || this._logLoadedWarning("getObjectsByClassName"), this.objects.filter(xA(e2));
  }
  getEntitiesByClassName(e2) {
    return this._loaded || this._logLoadedWarning("getEntitiesByClassName"), this.getObjectsByClassName(e2).map((e3) => this._objectToEntity.get(e3)).filter((e3) => !!e3);
  }
  getTemplates() {
    return this._loaded || this._logLoadedWarning("getTemplates"), this.objects.filter((e2) => e2 instanceof KA);
  }
  runFactory(e2) {
    var t, A2, i2, a2;
    const s2 = (0, OA.vec)(null !== (t = this.tiledObjectLayer.offsetx) && void 0 !== t ? t : 0, null !== (A2 = this.tiledObjectLayer.offsety) && void 0 !== A2 ? A2 : 0), r2 = this.objects.slice();
    for (let t2 of r2) {
      let A3 = t2.class;
      if (t2 instanceof KA && (A3 = A3 || t2.template.object.class), e2 !== A3) continue;
      let r3 = (0, OA.vec)((null !== (i2 = t2.x) && void 0 !== i2 ? i2 : 0) + s2.x, (null !== (a2 = t2.y) && void 0 !== a2 ? a2 : 0) + s2.y);
      "isometric" === this.resource.map.orientation && (r3 = this.resource.isometricTiledCoordToWorld(r3.x, r3.y));
      const n2 = this.resource.factories.get(e2);
      if (n2) {
        const e3 = n2({ worldPos: r3, name: t2.name, class: A3, layer: this, object: t2, properties: t2.properties });
        e3 && this._recordObjectEntityMapping(t2, e3);
      }
    }
  }
  _actorFromObject(e2, t, A2) {
    var i2, a2, s2, r2, n2, o2;
    const l2 = this.resource.headless, g2 = !!this.tiledObjectLayer.tintcolor, d2 = this.tiledObjectLayer.tintcolor ? OA.Color.fromHex(this.tiledObjectLayer.tintcolor) : OA.Color.White;
    if (e2 instanceof PA && A2) {
      const h2 = "isometric" === this.resource.map.orientation && "orthogonal" === A2.orientation ? "bottom" : void 0, c2 = A2.getTilesetAlignmentAnchor(h2);
      t.anchor = c2;
      const I2 = (null !== (i2 = e2.tiledObject.width) && void 0 !== i2 ? i2 : this.resource.map.tilewidth) / this.resource.map.tilewidth, u2 = (null !== (a2 = e2.tiledObject.width) && void 0 !== a2 ? a2 : this.resource.map.tilewidth) / this.resource.map.tilewidth, B2 = (0, OA.vec)(I2, u2);
      if (!l2) {
        const i3 = A2.getSpriteForGid(e2.gid).clone();
        i3.destSize.width = null !== (s2 = e2.tiledObject.width) && void 0 !== s2 ? s2 : i3.width, i3.destSize.height = null !== (r2 = e2.tiledObject.height) && void 0 !== r2 ? r2 : i3.height, g2 && (i3.tint = d2), t.graphics.use(i3), t.graphics.offset = A2.tileOffset;
        const a3 = A2.getAnimationForGid(e2.gid);
        if (a3) {
          const e3 = a3.clone();
          e3.scale = B2, g2 && (e3.tint = d2), t.graphics.use(e3), t.graphics.offset = A2.tileOffset;
        }
      }
      const C2 = null !== (n2 = e2.tiledObject.width) && void 0 !== n2 ? n2 : 0, p2 = null !== (o2 = e2.tiledObject.height) && void 0 !== o2 ? o2 : 0, f2 = -C2 * c2.x, Q2 = -p2 * c2.y, E2 = this.resource.map.tilewidth / 2, m2 = this.resource.map.tileheight;
      let y2 = (0, OA.vec)(f2, Q2);
      "isometric" === this.resource.map.orientation && (y2 = (0, OA.vec)(f2 + E2, Q2 + m2), "orthogonal" === A2.orientation && (y2 = y2.sub((0, OA.vec)(E2, m2))));
      const w2 = A2.getCollidersForGid(e2.gid, { anchor: OA.Vector.Zero, scale: B2, offset: y2 });
      if (w2.length) t.collider.useCompositeCollider(w2);
      else {
        let A3 = e2.width, i3 = e2.height;
        if ("isometric" === this.resource.map.orientation) {
          const t2 = e2.height / 2;
          A3 = t2, i3 = t2;
        }
        let a3 = OA.Shape.Box(A3, i3, "isometric" === this.resource.map.orientation ? (0, OA.vec)(1, 1) : (0, OA.vec)(0, 1));
        "isometric" === this.resource.map.orientation && (a3.points = a3.points.map((e3) => this.resource.isometricTiledCoordToWorld(e3.x, e3.y))), t.collider.set(a3);
      }
    }
    if (e2 instanceof VA && t.graphics.use(e2.text), e2 instanceof $A) {
      let A3 = (0, OA.vec)(e2.x, e2.y), i3 = e2.localPoints;
      "isometric" === this.resource.map.orientation && (A3 = this.resource.isometricTiledCoordToWorld(A3.x, A3.y), i3 = i3.map((e3) => this.resource.isometricTiledCoordToWorld(e3.x, e3.y))), t.anchor = (0, OA.vec)(0, 1), t.pos = A3;
      const a3 = OA.Shape.Polygon(i3, OA.Vector.Zero, true);
      a3.isConvex() ? t.collider.set(a3) : t.collider.set(a3.triangulate());
    }
    if (e2 instanceof XA) {
      t.anchor = e2.anchor;
      let A3 = OA.Shape.Box(e2.width, e2.height, e2.anchor);
      "isometric" === this.resource.map.orientation && (A3.points = A3.points.map((e3) => this.resource.isometricTiledCoordToWorld(e3.x, e3.y))), t.collider.set(A3);
    }
    e2 instanceof WA && t.collider.useCircleCollider(Math.min(e2.width, e2.height) / 2);
  }
  async load() {
    var e2, t, A2, i2, a2;
    const s2 = this.tiledObjectLayer.opacity, r2 = (0, OA.vec)(null !== (e2 = this.tiledObjectLayer.offsetx) && void 0 !== e2 ? e2 : 0, null !== (t = this.tiledObjectLayer.offsety) && void 0 !== t ? t : 0), n2 = Ai(this.tiledObjectLayer, this.resource);
    for (let e3 of n2) {
      let t2 = (0, OA.vec)((null !== (A2 = e3.x) && void 0 !== A2 ? A2 : 0) + r2.x, (null !== (i2 = e3.y) && void 0 !== i2 ? i2 : 0) + r2.y);
      "isometric" === this.resource.map.orientation && (t2 = this.resource.isometricTiledCoordToWorld(t2.x, t2.y));
      let n3, o2 = e3.class;
      if (e3 instanceof KA && (o2 = o2 || e3.template.object.class), o2) {
        const A3 = this.resource.factories.get(o2);
        if (A3) {
          const i3 = A3({ worldPos: t2, name: e3.name, class: o2, layer: this, object: e3, properties: e3.properties });
          i3 && this._recordObjectEntityMapping(e3, i3);
          continue;
        }
      }
      let l2 = this.properties.get(bA.ZIndex.ZIndex);
      "number" == typeof l2 && (n3 = l2);
      const g2 = new OA.Actor({ name: e3.tiledObject.name, pos: t2, anchor: OA.Vector.Zero, rotation: (0, OA.toRadians)(null !== (a2 = e3.tiledObject.rotation) && void 0 !== a2 ? a2 : 0), z: n3 }), d2 = g2.get(OA.GraphicsComponent);
      if (d2 && (d2.visible = this.tiledObjectLayer.visible && (void 0 === e3.tiledObject.visible || !!e3.tiledObject.visible), d2.opacity = s2), "isometric" === this.resource.map.orientation) {
        const e4 = new OA.IsometricEntityComponent({ rows: this.resource.map.height, columns: this.resource.map.width, tileWidth: this.resource.map.tilewidth, tileHeight: this.resource.map.tileheight });
        e4.elevation = null != n3 ? n3 : this.order, g2.addComponent(e4);
      }
      if (this.resource.useExcaliburWiring) {
        const t3 = e3.properties.get(bA.Collision.Type);
        if (t3 && "string" == typeof t3) switch (t3.toLowerCase()) {
          case OA.CollisionType.Active.toLowerCase():
            g2.body.collisionType = OA.CollisionType.Active;
            break;
          case OA.CollisionType.Fixed.toLowerCase():
            g2.body.collisionType = OA.CollisionType.Fixed;
            break;
          case OA.CollisionType.Passive.toLowerCase():
            g2.body.collisionType = OA.CollisionType.Passive;
            break;
          case OA.CollisionType.PreventCollision.toLowerCase():
            g2.body.collisionType = OA.CollisionType.PreventCollision;
            break;
          default:
            this.logger.warn(`Unknown collision type in layer ${this.name}, for object id ${e3.id} and name ${e3.name}: ${t3}`);
        }
      }
      if (e3 instanceof KA) {
        let t3 = e3.template.tileset, A3 = e3.template.object;
        A3 && (e3.gid && A3 instanceof PA && (t3 = this.resource.getTilesetForTileGid(e3.gid), A3 = new PA(A3.tiledObject, e3.gid, A3.width, A3.height)), this._actorFromObject(A3, g2, t3));
      } else {
        let t3;
        e3 instanceof PA && (t3 = this.resource.getTilesetForTileGid(e3.gid)), this._actorFromObject(e3, g2, t3);
      }
      this._recordObjectEntityMapping(e3, g2);
    }
    this._loaded = true;
  }
  _recordObjectEntityMapping(e2, t) {
    t.addComponent(new oi({ tiledObject: e2 })), this.objects.push(e2), this.entities.push(t), this._objectToEntity.set(e2, t), this._entityToObject.set(t, e2);
  }
};
var ci = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var Ii = (e2) => {
  if ("string" != typeof e2) throw new TypeError("Invalid argument expected string");
  const t = e2.match(ci);
  if (!t) throw new Error(`Invalid argument not valid semver ('${e2}' received)`);
  return t.shift(), t;
};
var ui = (e2) => "*" === e2 || "x" === e2 || "X" === e2;
var Bi = (e2) => {
  const t = parseInt(e2, 10);
  return isNaN(t) ? e2 : t;
};
var Ci = (e2, t) => {
  if (ui(e2) || ui(t)) return 0;
  const [A2, i2] = ((e3, t2) => typeof e3 != typeof t2 ? [String(e3), String(t2)] : [e3, t2])(Bi(e2), Bi(t));
  return A2 > i2 ? 1 : A2 < i2 ? -1 : 0;
};
var pi = (e2, t) => {
  for (let A2 = 0; A2 < Math.max(e2.length, t.length); A2++) {
    const i2 = Ci(e2[A2] || "0", t[A2] || "0");
    if (0 !== i2) return i2;
  }
  return 0;
};
var fi = (e2, t, A2) => {
  mi(A2);
  const i2 = ((e3, t2) => {
    const A3 = Ii(e3), i3 = Ii(t2), a2 = A3.pop(), s2 = i3.pop(), r2 = pi(A3, i3);
    return 0 !== r2 ? r2 : a2 && s2 ? pi(a2.split("."), s2.split(".")) : a2 || s2 ? a2 ? -1 : 1 : 0;
  })(e2, t);
  return Qi[A2].includes(i2);
};
var Qi = { ">": [1], ">=": [0, 1], "=": [0], "<=": [-1, 0], "<": [-1], "!=": [-1, 1] };
var Ei = Object.keys(Qi);
var mi = (e2) => {
  if ("string" != typeof e2) throw new TypeError("Invalid operator type, expected string but got " + typeof e2);
  if (-1 === Ei.indexOf(e2)) throw new Error(`Invalid operator, expected one of ${Ei.join("|")}`);
};
var yi = class {
  constructor(e2, t, A2) {
    this.tiledImageLayer = e2, this.resource = t, this.order = A2, this.properties = /* @__PURE__ */ new Map(), this.image = null, this.imageActor = null, this.name = e2.name, this.class = e2.class, qA(this, e2.properties), e2.image && (this.image = new OA.ImageSource(YA(this.resource.path, e2.image, this.resource.pathMap)));
  }
  async load() {
    var e2, t, A2, i2;
    const a2 = this.tiledImageLayer.opacity, s2 = !!this.tiledImageLayer.tintcolor, r2 = this.tiledImageLayer.tintcolor ? OA.Color.fromHex(this.tiledImageLayer.tintcolor) : OA.Color.White, n2 = (0, OA.vec)(null !== (e2 = this.tiledImageLayer.offsetx) && void 0 !== e2 ? e2 : 0, null !== (t = this.tiledImageLayer.offsety) && void 0 !== t ? t : 0), o2 = null !== (A2 = this.tiledImageLayer.parallaxx) && void 0 !== A2 ? A2 : 1, l2 = null !== (i2 = this.tiledImageLayer.parallaxy) && void 0 !== i2 ? i2 : 1;
    if (this.image) {
      this.resource.headless || await this.image.load(), this.imageActor = new OA.Actor({ name: this.tiledImageLayer.name, pos: n2, anchor: OA.Vector.Zero, z: this.order }), this.imageActor.addComponent(new OA.ParallaxComponent((0, OA.vec)(o2, l2)));
      const e3 = this.image.toSprite();
      this.imageActor.graphics.use(e3), this.imageActor.graphics.visible = this.tiledImageLayer.visible, this.imageActor.graphics.opacity = a2, s2 && (e3.tint = r2);
    }
  }
};
var wi = class _wi {
  constructor(e2, t) {
    this.path = e2, this.logger = OA.Logger.getInstance(), this.tilesets = [], this.templates = [], this.layers = [], this.mapFormat = "TMX", this.strict = true, this.factories = /* @__PURE__ */ new Map(), this.parser = new pA(), this.fileLoader = kA, this.startZIndex = 0, this.textQuality = 4, this.useExcaliburWiring = true, this.useMapBackgroundColor = false, this.useTilemapCameraStrategy = false, this.headless = false, this.layerConfig = {}, this._imageLoader = new UA(OA.ImageSource), this._tilesetLoader = new UA(ri), this._templateLoader = new UA(ni);
    const { mapFormatOverride: A2, textQuality: i2, entityClassNameFactories: a2, useExcaliburWiring: s2, useTilemapCameraStrategy: r2, useMapBackgroundColor: n2, layerConfig: o2, pathMap: l2, fileLoader: g2, strict: d2, headless: h2, startZIndex: c2 } = { ...t };
    this.strict = null != d2 ? d2 : this.strict, this.headless = null != h2 ? h2 : this.headless, this.useExcaliburWiring = null != s2 ? s2 : this.useExcaliburWiring, this.useTilemapCameraStrategy = null != r2 ? r2 : this.useTilemapCameraStrategy, this.useMapBackgroundColor = null != n2 ? n2 : this.useMapBackgroundColor, this.layerConfig = null != o2 ? o2 : this.layerConfig, this.textQuality = null != i2 ? i2 : this.textQuality, this.startZIndex = null != c2 ? c2 : this.startZIndex, this.fileLoader = null != g2 ? g2 : this.fileLoader, this.pathMap = l2;
    for (const e3 in a2) this.registerEntityFactory(e3, a2[e3]);
    this.mapFormat = null != A2 ? A2 : e2.includes(".tmx") ? "TMX" : "TMJ";
  }
  registerEntityFactory(e2, t) {
    if (this.factories.has(e2) && console.warn(`Another factory has already been registered for tiled class/type "${e2}", this is probably a bug.`), this.factories.set(e2, t), this.isLoaded()) for (let t2 of this.getObjectLayers()) t2.runFactory(e2);
  }
  unregisterEntityFactory(e2) {
    this.factories.has(e2) || console.warn(`No factory has been registered for tiled class/type "${e2}", cannot unregister!`), this.factories.delete(e2);
  }
  getLayerConfig(e2) {
    return this.layerConfig[e2];
  }
  getTilesetForTileGid(e2) {
    const t = MA(e2);
    if (this.tilesets) {
      for (let e3 of this.tilesets) if (t >= e3.firstGid && t <= e3.firstGid + e3.tileCount - 1) return e3;
    }
    throw Error(`No tileset exists for tiled gid [${e2}] normalized [${t}]!`);
  }
  getTilesetByName(e2) {
    return this.tilesets.filter(DA(e2));
  }
  getTilesetByClassName(e2) {
    return this.tilesets.filter(xA(e2));
  }
  getTilesetByProperty(e2, t) {
    return this.tilesets.filter(LA(e2, t));
  }
  getTileMetadataByClassName(e2) {
    let t = [];
    for (let A2 of this.tilesets) t = t.concat(A2.tiles.filter(xA(e2)));
    return t;
  }
  getTileMetadataByProperty(e2, t) {
    let A2 = [];
    for (let i2 of this.tilesets) A2 = A2.concat(i2.tiles.filter(LA(e2, t)));
    return A2;
  }
  getTilesByGid(e2) {
    if ("orthogonal" === this.map.orientation) {
      let t = [];
      for (let A2 of this.getTileLayers()) t = t.concat(A2.getTilesByGid(e2));
      return t;
    }
    {
      let t = [];
      for (let A2 of this.getIsoTileLayers()) t = t.concat(A2.getTilesByGid(e2));
      return t;
    }
  }
  getTilesByClassName(e2) {
    if ("orthogonal" === this.map.orientation) {
      let t = [];
      for (let A2 of this.getTileLayers()) t = t.concat(A2.getTilesByClassName(e2));
      return t;
    }
    {
      let t = [];
      for (let A2 of this.getIsoTileLayers()) t = t.concat(A2.getTilesByClassName(e2));
      return t;
    }
  }
  getTilesByProperty(e2, t) {
    if ("orthogonal" === this.map.orientation) {
      let A2 = [];
      for (let i2 of this.getTileLayers()) A2 = A2.concat(i2.getTilesByProperty(e2, t));
      return A2;
    }
    {
      let A2 = [];
      for (let i2 of this.getIsoTileLayers()) A2 = A2.concat(i2.getTilesByProperty(e2, t));
      return A2;
    }
  }
  getTileByPoint(e2, t) {
    if ("isometric" === this.map.orientation) {
      const A2 = this.getIsoTileLayers().find(DA(e2));
      if (A2) return A2.getTileByPoint(t);
    } else {
      const A2 = this.getTileLayers().find(DA(e2));
      if (A2) return A2.getTileByPoint(t);
    }
    return null;
  }
  getTilesByPoint(e2) {
    if ("orthogonal" === this.map.orientation) {
      let t = [];
      for (let A2 of this.getTileLayers()) {
        const i2 = A2.getTileByPoint(e2);
        i2 && t.push(i2);
      }
      return t;
    }
    {
      let t = [];
      for (let A2 of this.getIsoTileLayers()) {
        const i2 = A2.getTileByPoint(e2);
        i2 && t.push(i2);
      }
      return t;
    }
  }
  getObjectsByName(e2) {
    let t = [];
    for (let A2 of this.getObjectLayers()) t = t.concat(A2.getObjectsByName(e2));
    return t;
  }
  getEntitiesByName(e2) {
    let t = [];
    for (let A2 of this.getObjectLayers()) t = t.concat(A2.getEntitiesByName(e2));
    return t;
  }
  getEntityByObject(e2) {
    for (let t of this.getObjectLayers()) {
      const A2 = t.getEntityByObject(e2);
      if (A2) return A2;
    }
  }
  getObjectByEntity(e2) {
    for (let t of this.getObjectLayers()) {
      const A2 = t.getObjectByEntity(e2);
      if (A2) return A2;
    }
  }
  getObjectsByProperty(e2, t) {
    let A2 = [];
    for (let i2 of this.getObjectLayers()) A2 = A2.concat(i2.getObjectsByProperty(e2, t));
    return A2;
  }
  getEntitiesByProperty(e2, t) {
    let A2 = [];
    for (let i2 of this.getObjectLayers()) A2 = A2.concat(i2.getEntitiesByProperty(e2, t));
    return A2;
  }
  getObjectsByClassName(e2) {
    let t = [];
    for (let A2 of this.getObjectLayers()) t = t.concat(A2.getObjectsByClassName(e2));
    return t;
  }
  getEntitiesByClassName(e2) {
    let t = [];
    for (let A2 of this.getObjectLayers()) t = t.concat(A2.getEntitiesByClassName(e2));
    return t;
  }
  getTileByCoordinate(e2, t, A2) {
    const i2 = this.getTileLayers().find(DA(e2));
    return i2 ? i2.getTileByCoordinate(t, A2) : null;
  }
  getImageLayers(e2) {
    const t = this.layers.filter((e3) => e3 instanceof yi);
    return e2 ? t.filter(DA(e2)) : t;
  }
  getTileLayers(e2) {
    const t = this.layers.filter((e3) => e3 instanceof di);
    return e2 ? t.filter(DA(e2)) : t;
  }
  getIsoTileLayers(e2) {
    const t = this.layers.filter((e3) => e3 instanceof gi);
    return e2 ? t.filter(DA(e2)) : t;
  }
  getObjectLayers(e2) {
    const t = this.layers.filter((e3) => e3 instanceof hi);
    return e2 ? t.filter(DA(e2)) : t;
  }
  getLayersByName(e2) {
    return this.layers.filter(DA(e2));
  }
  getLayersByClassName(e2) {
    return this.layers.filter(xA(e2));
  }
  getLayersByProperty(e2, t) {
    return this.layers.filter(LA(e2, t));
  }
  _parseMap(e2) {
    return "TMX" === this.mapFormat ? this.parser.parse(e2, this.strict) : e2;
  }
  async load() {
    var e2;
    const t = await this.fileLoader(this.path, "TMX" === this.mapFormat ? "xml" : "json");
    let A2;
    if (this.strict) try {
      A2 = this._parseMap(t);
    } catch (e3) {
      throw console.error(`Could not parse tiled map from location ${this.path}, attempted to interpret as ${this.mapFormat}.
Excalibur only supports the latest version of Tiled formats as of the plugin's release.`), console.error("Is your map file corrupted or being interpreted as the wrong type?"), e3;
    }
    else A2 = this._parseMap(t);
    fi(_wi.supportedTiledVersion, null !== (e2 = A2.tiledversion) && void 0 !== e2 ? e2 : "0.0.0", ">") && console.warn(`The excalibur tiled plugin officially supports ${_wi.supportedTiledVersion}+, the current map has tiled version ${A2.tiledversion}`), this.map = A2, this._collectTilesets(), this._collectTemplates(), await Promise.all([this._tilesetLoader.load(), this.headless ? Promise.resolve() : this._imageLoader.load(), this._templateLoader.load()]), this.tilesets = [...this.tilesets, ...this._tilesetLoader.values().map((e3) => e3.data)], this.templates = this._templateLoader.values().map((e3) => e3.data);
    let i2 = [], a2 = this.startZIndex;
    for (const e3 of this.map.layers) {
      if ("tilelayer" === e3.type) {
        if ("isometric" === this.map.orientation) {
          const t2 = new gi(e3, this, a2);
          i2.push(t2);
        }
        if ("orthogonal" === this.map.orientation) {
          const t2 = new di(e3, this, a2);
          i2.push(t2);
        }
      }
      if ("objectgroup" === e3.type) {
        const t2 = new hi(e3, this, a2);
        i2.push(t2);
      }
      if ("imagelayer" === e3.type) {
        const t2 = new yi(e3, this, a2);
        i2.push(t2);
      }
      a2++;
    }
    await Promise.all(i2.map((e3) => e3.load())), this.layers = i2;
  }
  _collectTilesets() {
    for (const e2 of this.map.tilesets) {
      if (uA(e2)) {
        if (nA(e2)) {
          const t = YA(this.path, e2.image, this.pathMap), A2 = this._imageLoader.getOrAdd(t), i2 = new si({ name: e2.name, tiledTileset: e2, image: A2, firstGid: e2.firstgid });
          this.tilesets.push(i2);
        }
        if (oA(e2)) {
          const t = /* @__PURE__ */ new Map();
          if (e2.tiles) {
            for (let A3 of e2.tiles) if (A3.image) {
              const e3 = YA(this.path, A3.image, this.pathMap), i2 = this._imageLoader.getOrAdd(e3);
              t.set(A3, i2);
            }
          }
          const A2 = new si({ name: e2.name, tiledTileset: e2, tileToImage: t, firstGid: e2.firstgid });
          this.tilesets.push(A2);
        }
      }
      if (BA(e2)) {
        const t = YA(this.path, e2.source, this.pathMap);
        this._tilesetLoader.getOrAdd(t, e2.firstgid, { strict: this.strict, headless: this.headless, parser: this.parser, fileLoader: this.fileLoader, imageLoader: this._imageLoader, pathMap: this.pathMap });
      }
    }
  }
  _collectTemplates() {
    let e2 = [];
    for (const t2 of this.map.layers) if ("objectgroup" === t2.type) {
      let A2 = t2.objects.filter((e3) => e3.template).map((e3) => e3.template);
      e2 = e2.concat(A2);
    }
    const t = e2.filter((e3, t2, A2) => A2.findIndex((t3) => t3 === e3) === t2);
    for (const e3 of t) {
      const t2 = YA(this.path, e3, this.pathMap);
      this._templateLoader.getOrAdd(t2, { strict: this.strict, headless: this.headless, parser: this.parser, fileLoader: this.fileLoader, imageLoader: this._imageLoader, pathMap: this.pathMap });
    }
  }
  addToScene(e2, t) {
    if (!this.isLoaded()) return void this.logger.warn(`TiledResource ${this.path} is not loaded! Nothing will be wired into excalibur!`);
    const A2 = { pos: (0, OA.vec)(0, 0) }, { pos: i2 } = { ...A2, ...t };
    for (const t2 of this.layers) {
      if (t2 instanceof di && (t2.tilemap.pos = t2.tilemap.pos.add(i2), e2.add(t2.tilemap)), t2 instanceof gi && e2.add(t2.isometricMap), t2 instanceof hi) for (const A3 of t2.entities) {
        const t3 = A3.get(OA.TransformComponent);
        t3 && (t3.pos = t3.pos.add(i2)), e2.add(A3);
      }
      t2 instanceof yi && t2.imageActor && (t2.imageActor.pos = t2.imageActor.pos.add(i2), e2.add(t2.imageActor));
    }
    if (this.useExcaliburWiring) {
      const t2 = this.getObjectsByProperty(bA.Camera.Camera, true);
      if (t2 && t2.length) {
        const A3 = t2[0];
        let i3 = 1;
        const a2 = A3.properties.get(bA.Camera.Zoom);
        a2 && "number" == typeof a2 && (i3 = a2), "isometric" === this.map.orientation ? e2.camera.pos = this.isometricTiledCoordToWorld(A3.x, A3.y) : e2.camera.pos = (0, OA.vec)(A3.x, A3.y), e2.camera.zoom = i3;
      }
    }
    if (this.useTilemapCameraStrategy) {
      const t2 = this.getTileLayers()[0];
      if (t2) {
        const A3 = OA.BoundingBox.fromDimension(this.map.width * this.map.tilewidth, this.map.height * this.map.tileheight, OA.Vector.Zero, i2.add(t2.tilemap.pos));
        e2.camera.strategy.limitCameraBounds(A3);
      }
    }
    this.useMapBackgroundColor && this.map.backgroundcolor && (e2.backgroundColor = OA.Color.fromHex(this.map.backgroundcolor));
  }
  isometricTiledCoordToWorld(e2, t) {
    const A2 = this.map.tilewidth, i2 = this.map.tileheight, a2 = t / i2, s2 = e2 / i2;
    return (0, OA.vec)((s2 - a2) * A2 / 2 + 0, (s2 + a2) * i2 / 2);
  }
  isLoaded() {
    return !!this.map;
  }
};
wi.supportedTiledVersion = "1.10.1";
var _i = n.XM;
var vi = n.Pp;
var bi = n.B8;
var ki = n.Z9;
var Di = n.Ms;
var xi = n.yO;
var Li = n.UZ;
var Si = n.fN;
var Fi = n._k;
var Gi = n.J4;
var Ti = n.bR;
var Ni = n.tS;
var Ri = n.Ro;
var Mi = n.M_;
var Ui = n.Bj;
var Oi = n.HZ;
var qi = n.xn;
var ji = n.EY;
var Ji = n.FA;
var Zi = n.o4;
var Yi = n.$u;
var Hi = n.ZR;
var Ki = n.uE;
var Pi = n.Bf;
var zi = n.xm;
var Vi = n.OK;
var Wi = n.r0;
var Xi = n.IB;
var $i = n.cp;
var ea = n.pE;
var ta = n.fO;
var Aa = n.pf;
var ia = n.fc;
var aa = n.NW;
var sa = n.OW;
var ra = n.I;
var na = n.N5;
var oa = n.fd;
var la = n.zU;
var ga = n.RT;
var da = n.SW;
var ha = n.s;
var ca = n.mD;
var Ia = n.wi;
var ua = n.tP;
var Ba = n.YK;
var Ca = n.Ey;
var pa = n.qD;
var fa = n.rr;
var Qa = n.Xs;
var Ea = n.lj;
var ma = n.MB;
var ya = n.hu;
var wa = n.Uk;
export {
  _i as Decoder,
  vi as Ellipse,
  bi as ExcaliburTiledProperties,
  ki as FLIPPED_DIAGONALLY_FLAG,
  Di as FLIPPED_HORIZONTALLY_FLAG,
  xi as FLIPPED_VERTICALLY_FLAG,
  Li as FetchLoader,
  Si as InsertedTile,
  Fi as LoaderCache,
  Gi as PluginObject,
  Ti as Point,
  Ni as Polygon,
  Ri as Polyline,
  Mi as Rectangle,
  Ui as Template,
  Oi as TemplateObject,
  qi as TemplateResource,
  ji as Text,
  Ji as Tile,
  Zi as TiledDataComponent,
  Yi as TiledLayerDataComponent,
  Hi as TiledMap,
  Ki as TiledParser,
  Pi as TiledResource,
  zi as TiledTemplate,
  Vi as TiledText,
  Wi as TiledTile,
  Xi as TiledTileLayer,
  $i as TiledTileLayerInfinite,
  ea as TiledTileset,
  ta as TiledTilesetFile,
  Aa as Tileset,
  ia as TilesetResource,
  aa as byClassCaseInsensitive,
  sa as byNameCaseInsensitive,
  ra as byPropertyCaseInsensitive,
  na as filenameFromPath,
  oa as getCanonicalGid,
  la as isCSV,
  ga as isFlippedDiagonally,
  da as isFlippedHorizontally,
  ha as isFlippedVertically,
  ca as isInfiniteLayer,
  Ia as isTiledTilesetCollectionOfImages,
  ua as isTiledTilesetEmbedded,
  Ba as isTiledTilesetExternal,
  Ca as isTiledTilesetSingleImage,
  pa as mapPath,
  fa as mapProps,
  Qa as needsDecoding,
  Ea as parseObject,
  ma as parseObjects,
  ya as pathInMap,
  wa as pathRelativeToBase
};
//# sourceMappingURL=@excaliburjs_plugin-tiled.js.map
